<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.61" />
    <meta name="theme" content="VuePress Theme Hope" />
    <link rel="icon" href="https://jklk-1304336794.cos.ap-nanjing.myqcloud.com/default/icon/icon.png"><title>Java集合常见面试题</title><meta name="description" content="CY">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-ff3b8345.css" as="style"><link rel="stylesheet" href="/assets/style-ff3b8345.css">
    <link rel="modulepreload" href="/assets/app-40618983.js"><link rel="modulepreload" href="/assets/framework-91490e6a.js"><link rel="modulepreload" href="/assets/java-collection-01.html-916f3930.js"><link rel="modulepreload" href="/assets/java-collection-01.html-d9a31969.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/" class="brand"><img class="logo" src="https://jklk-1304336794.cos.ap-nanjing.myqcloud.com/default/logo/logo.png" alt><!----><!----></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/" class="nav-link" aria-label="主页"><span class="font-icon icon iconfont icon-iconfont icon-home-fill" style=""></span>主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/md/interview/" class="nav-link active" aria-label="面试"><span class="font-icon icon iconfont icon-iconfont icon-mianshi" style=""></span>面试<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Java"><span class="title"><span class="font-icon icon iconfont icon-iconfont icon-java1" style=""></span>Java</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Java 基础</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/java/basic/java-basic-oop.html" class="nav-link" aria-label="Java 面向对象"><!---->Java 面向对象<!----></a></li><li class="dropdown-subitem"><a href="/md/java/basic/java-basic-lan.html" class="nav-link" aria-label="Java 基础知识"><!---->Java 基础知识<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Java IO</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/java/io/java-io.html" class="nav-link" aria-label="Java IO "><!---->Java IO <!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Java 反射</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/java/reflect/java-reflect.html" class="nav-link" aria-label="Java 反射 "><!---->Java 反射 <!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Java 集合</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/java/collection/java-collection.html" class="nav-link" aria-label="Java 集合框架"><!---->Java 集合框架<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="数据库"><span class="title"><span class="font-icon icon iconfont icon-iconfont icon-shujuku1" style=""></span>数据库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>数据库基础</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/db/sql/sql-db.html" class="nav-link" aria-label="数据库原理"><!---->数据库原理<!----></a></li><li class="dropdown-subitem"><a href="/md/db/sql/sql-lan.html" class="nav-link" aria-label="SQL语言"><!---->SQL语言<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>SQL数据库</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/db/sql-mysql/sql-mysql-overview.html" class="nav-link" aria-label="MySQL"><!---->MySQL<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>NoSQL数据库</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/db/nosql-redis/sql-redis-overview.html" class="nav-link" aria-label="Redis"><!---->Redis<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="Spring"><span class="title"><span class="font-icon icon iconfont icon-iconfont icon-leaf1" style=""></span>Spring</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Spring 知识体系</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/spring/spring.html" class="nav-link" aria-label="Spring Framework"><!---->Spring Framework<!----></a></li><li class="dropdown-subitem"><a href="/md/spring/SpringCloud.html" class="nav-link" aria-label="Spring Cloud"><!---->Spring Cloud<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" aria-label="框架"><span class="title"><span class="font-icon icon iconfont icon-iconfont icon-mn_kuangjia_fill" style=""></span>框架</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>ORM框架</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/md/framework/orm-mybatis/mybatis-overview.html" class="nav-link" aria-label="Mybatis"><!---->Mybatis<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><a href="/about-me.html" class="nav-link" aria-label="关于作者"><span class="font-icon icon iconfont icon-iconfont icon-aboutme" style=""></span>关于作者<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><!----><div class="nav-item hide-in-mobile"><button class="outlook-button" tabindex="-1" ariahidden="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon outlook-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="outlook icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4 38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32 51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0 102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2 6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4 0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2 9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224 419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4 470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0 22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6 12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128 505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2 16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8 86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4 80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6 6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg><div class="outlook-dropdown"><!----></div></button></div><!--[--><button class="search-pro-button" role="search" aria-label="搜索"><svg xmlns="http://www.w3.org/2000/svg" class="icon search-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="search icon"><path d="M192 480a256 256 0 1 1 512 0 256 256 0 0 1-512 0m631.776 362.496-143.2-143.168A318.464 318.464 0 0 0 768 480c0-176.736-143.264-320-320-320S128 303.264 128 480s143.264 320 320 320a318.016 318.016 0 0 0 184.16-58.592l146.336 146.368c12.512 12.48 32.768 12.48 45.28 0 12.48-12.512 12.48-32.768 0-45.28"></path></svg><div class="placeholder">搜索</div><div class="key-hints"><kbd class="key">Ctrl</kbd><kbd class="key">K</kbd></div></button><!--]--><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/md/interview/" class="nav-link sidebar-link sidebar-page" aria-label="目录"><!---->目录<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><section class="sidebar-group"><button class="sidebar-heading clickable active"><span class="font-icon icon iconfont icon-iconfont icon-java1" style=""></span><span class="title">Java</span><span class="arrow down"></span></button><ul class="sidebar-links"><li><!--[--><a href="/md/interview/java/java-basic-01.html" class="nav-link sidebar-link sidebar-page" aria-label="Java基础"><!---->Java基础<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/md/interview/java/java-io-01.html" class="nav-link sidebar-link sidebar-page" aria-label="JavaIO"><!---->JavaIO<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/md/interview/java/java-reflex-01.html" class="nav-link sidebar-link sidebar-page" aria-label="Java反射"><!---->Java反射<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/md/interview/java/java-generic-01.html" class="nav-link sidebar-link sidebar-page" aria-label="Java泛型"><!---->Java泛型<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/md/interview/java/java-enum-01.html" class="nav-link sidebar-link sidebar-page" aria-label="Java枚举"><!---->Java枚举<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/md/interview/java/java-collection-01.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="Java集合"><!---->Java集合<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#java中有哪些集合类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="Java中有哪些集合类？"><!---->Java中有哪些集合类？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-2-集合类中线程安全与不安全的分别有哪些" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.2 集合类中线程安全与不安全的分别有哪些？"><!---->6.2 集合类中线程安全与不安全的分别有哪些？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-3-map接口有哪些实现类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.3 Map接口有哪些实现类？"><!---->6.3 Map接口有哪些实现类？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-4-map-put的过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.4 Map put的过程"><!---->6.4 Map put的过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-5-如何得到一个线程安全的map" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.5 如何得到一个线程安全的Map？"><!---->6.5 如何得到一个线程安全的Map？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-6-hashmap的特点" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.6 HashMap的特点？"><!---->6.6 HashMap的特点？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-7-jdk7与jdk8之间的hashmap有什么区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.7 JDK7与JDK8之间的HashMap有什么区别？"><!---->6.7 JDK7与JDK8之间的HashMap有什么区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-8-arraylist与linkedlist的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.8 ArrayList与LinkedList的区别？"><!---->6.8 ArrayList与LinkedList的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-9-copyonwritearraylist的底层原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.9 CopyOnWriteArrayList的底层原理"><!---->6.9 CopyOnWriteArrayList的底层原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-10-hashmap的底层实现原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.10 HashMap的底层实现原理"><!---->6.10 HashMap的底层实现原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-11-hashmap的扩容机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.11 HashMap的扩容机制"><!---->6.11 HashMap的扩容机制<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-12-hashmap中循环链表如何产生" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.12 HashMap中循环链表如何产生？"><!---->6.12 HashMap中循环链表如何产生？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-13-hashmap为什么是用红黑树-而不是b树" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.13 HashMap为什么是用红黑树，而不是B树？"><!---->6.13 HashMap为什么是用红黑树，而不是B树？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-14-hashmap为什么线程不安全" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.14 HashMap为什么线程不安全？"><!---->6.14 HashMap为什么线程不安全？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-15-hashmap如何实现线程安全" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.15 HashMap如何实现线程安全？"><!---->6.15 HashMap如何实现线程安全？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-16-hashmap如何解决hash冲突的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.16 HashMap如何解决hash冲突的？"><!---->6.16 HashMap如何解决hash冲突的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-17-说一说hashmap和hashtable的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.17 说一说HashMap和Hashtable的区别？"><!---->6.17 说一说HashMap和Hashtable的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-18-hashmap与concurrenthashmap的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.18 HashMap与ConcurrentHashMap的区别？"><!---->6.18 HashMap与ConcurrentHashMap的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-19-concurrenthashmap是如何实现的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.19 ConcurrentHashMap是如何实现的？"><!---->6.19 ConcurrentHashMap是如何实现的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-20-concurrenthashmap是如何分段分组的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.20 ConcurrentHashMap是如何分段分组的？"><!---->6.20 ConcurrentHashMap是如何分段分组的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-21-说说你对linkedhashmap的理解" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.21 说说你对LinkedHashMap的理解？"><!---->6.21 说说你对LinkedHashMap的理解？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-22-linkedhashmap的底层原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.22 LinkedHashMap的底层原理"><!---->6.22 LinkedHashMap的底层原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-23-treemap的底层原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.23 TreeMap的底层原理"><!---->6.23 TreeMap的底层原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-24-map与set的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.24 Map与Set的区别？"><!---->6.24 Map与Set的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-25-list与set的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.25 List与Set的区别？"><!---->6.25 List与Set的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-26-有哪些线程安全的list" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.26 有哪些线程安全的List？"><!---->6.26 有哪些线程安全的List？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-27-arraylist的数据结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.27 ArrayList的数据结构"><!---->6.27 ArrayList的数据结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-28-treeset与hashset的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.28 TreeSet与HashSet的区别？"><!---->6.28 TreeSet与HashSet的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-29-hashset的底层结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.29 HashSet的底层结构"><!---->6.29 HashSet的底层结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-30-blockingqueue有哪些方法-为什么这样设计" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.30 BlockingQueue有哪些方法？为什么这样设计？"><!---->6.30 BlockingQueue有哪些方法？为什么这样设计？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-31-blockingqueue如何实现的" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.31 BlockingQueue如何实现的？"><!---->6.31 BlockingQueue如何实现的？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-32-stream-不是iostream-有哪些方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.32 Stream（不是IOStream）有哪些方法？"><!---->6.32 Stream（不是IOStream）有哪些方法？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-33-vector和synchronizedlist的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.33 Vector和SynchronizedList的区别？"><!---->6.33 Vector和SynchronizedList的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-36-同步代码块与同步方法的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.36 同步代码块与同步方法的区别？"><!---->6.36 同步代码块与同步方法的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-37-set如何保证元素不重复" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.37 Set如何保证元素不重复？"><!---->6.37 Set如何保证元素不重复？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-38-hashmap中的hash方法的原理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.38 HashMap中的hash方法的原理"><!---->6.38 HashMap中的hash方法的原理<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-39-常见的hash函数" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.39 常见的hash函数"><!---->6.39 常见的hash函数<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-40-hashmap的数据结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.40 HashMap的数据结构"><!---->6.40 HashMap的数据结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-41-collection如何迭代" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.41 Collection如何迭代？"><!---->6.41 Collection如何迭代？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-42-enumeration和iterator的区别" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.42 Enumeration和Iterator的区别？"><!---->6.42 Enumeration和Iterator的区别？<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-43-如何在遍历的同时删除arraylist的中的元素" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.43 如何在遍历的同时删除ArrayList的中的元素？"><!---->6.43 如何在遍历的同时删除ArrayList的中的元素？<!----></a><ul class="sidebar-sub-headers"></ul></li></ul><!--]--></li></ul></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-iconfont icon-mn_kuangjia_fill" style=""></span><span class="title">常用框架</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-iconfont icon-shujuku1" style=""></span><span class="title">数据库</span><span class="arrow end"></span></button><!----></section></li><li><section class="sidebar-group"><button class="sidebar-heading clickable"><span class="font-icon icon iconfont icon-iconfont icon-mianshi" style=""></span><span class="title">复盘记录</span><span class="arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="font-icon icon iconfont icon-article" style=""></span>Java集合常见面试题</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://xcy.icu" target="_blank" rel="noopener noreferrer">CY</a></span><span property="author" content="CY"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2022-01-20T00:00:00.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 23 分钟</span><meta property="timeRequired" content="PT23M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category4 clickable" role="navigation">Java</span><meta property="articleSection" content="Java"></span><span class="page-tag-info" aria-label="标签🏷" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon tag-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="tag icon"><path d="M939.902 458.563L910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 000 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z"></path></svg><span class="page-tag-item tag2 clickable" role="navigation">Java集合</span><meta property="keywords" content="Java集合"></span></div><hr></div><div class="toc-place-holder"><aside id="toc"><!--[--><!----><!--]--><div class="toc-header">此页内容<button class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#java集合常见面试题" class="router-link-active router-link-exact-active toc-link level1">Java集合常见面试题</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#java中有哪些集合类" class="router-link-active router-link-exact-active toc-link level3">Java中有哪些集合类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-2-集合类中线程安全与不安全的分别有哪些" class="router-link-active router-link-exact-active toc-link level3">6.2 集合类中线程安全与不安全的分别有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-3-map接口有哪些实现类" class="router-link-active router-link-exact-active toc-link level3">6.3 Map接口有哪些实现类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-4-map-put的过程" class="router-link-active router-link-exact-active toc-link level3">6.4 Map put的过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-5-如何得到一个线程安全的map" class="router-link-active router-link-exact-active toc-link level3">6.5 如何得到一个线程安全的Map？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-6-hashmap的特点" class="router-link-active router-link-exact-active toc-link level3">6.6 HashMap的特点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-7-jdk7与jdk8之间的hashmap有什么区别" class="router-link-active router-link-exact-active toc-link level3">6.7 JDK7与JDK8之间的HashMap有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-8-arraylist与linkedlist的区别" class="router-link-active router-link-exact-active toc-link level3">6.8 ArrayList与LinkedList的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-9-copyonwritearraylist的底层原理" class="router-link-active router-link-exact-active toc-link level3">6.9 CopyOnWriteArrayList的底层原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-10-hashmap的底层实现原理" class="router-link-active router-link-exact-active toc-link level3">6.10 HashMap的底层实现原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-11-hashmap的扩容机制" class="router-link-active router-link-exact-active toc-link level3">6.11 HashMap的扩容机制</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-12-hashmap中循环链表如何产生" class="router-link-active router-link-exact-active toc-link level3">6.12 HashMap中循环链表如何产生？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-13-hashmap为什么是用红黑树-而不是b树" class="router-link-active router-link-exact-active toc-link level3">6.13 HashMap为什么是用红黑树，而不是B树？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-14-hashmap为什么线程不安全" class="router-link-active router-link-exact-active toc-link level3">6.14 HashMap为什么线程不安全？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-15-hashmap如何实现线程安全" class="router-link-active router-link-exact-active toc-link level3">6.15 HashMap如何实现线程安全？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-16-hashmap如何解决hash冲突的" class="router-link-active router-link-exact-active toc-link level3">6.16 HashMap如何解决hash冲突的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-17-说一说hashmap和hashtable的区别" class="router-link-active router-link-exact-active toc-link level3">6.17 说一说HashMap和Hashtable的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-18-hashmap与concurrenthashmap的区别" class="router-link-active router-link-exact-active toc-link level3">6.18 HashMap与ConcurrentHashMap的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-19-concurrenthashmap是如何实现的" class="router-link-active router-link-exact-active toc-link level3">6.19 ConcurrentHashMap是如何实现的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-20-concurrenthashmap是如何分段分组的" class="router-link-active router-link-exact-active toc-link level3">6.20 ConcurrentHashMap是如何分段分组的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-21-说说你对linkedhashmap的理解" class="router-link-active router-link-exact-active toc-link level3">6.21 说说你对LinkedHashMap的理解？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-22-linkedhashmap的底层原理" class="router-link-active router-link-exact-active toc-link level3">6.22 LinkedHashMap的底层原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-23-treemap的底层原理" class="router-link-active router-link-exact-active toc-link level3">6.23 TreeMap的底层原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-24-map与set的区别" class="router-link-active router-link-exact-active toc-link level3">6.24 Map与Set的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-25-list与set的区别" class="router-link-active router-link-exact-active toc-link level3">6.25 List与Set的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-26-有哪些线程安全的list" class="router-link-active router-link-exact-active toc-link level3">6.26 有哪些线程安全的List？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-27-arraylist的数据结构" class="router-link-active router-link-exact-active toc-link level3">6.27 ArrayList的数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-28-treeset与hashset的区别" class="router-link-active router-link-exact-active toc-link level3">6.28 TreeSet与HashSet的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-29-hashset的底层结构" class="router-link-active router-link-exact-active toc-link level3">6.29 HashSet的底层结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-30-blockingqueue有哪些方法-为什么这样设计" class="router-link-active router-link-exact-active toc-link level3">6.30 BlockingQueue有哪些方法？为什么这样设计？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-31-blockingqueue如何实现的" class="router-link-active router-link-exact-active toc-link level3">6.31 BlockingQueue如何实现的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-32-stream-不是iostream-有哪些方法" class="router-link-active router-link-exact-active toc-link level3">6.32 Stream（不是IOStream）有哪些方法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-33-vector和synchronizedlist的区别" class="router-link-active router-link-exact-active toc-link level3">6.33 Vector和SynchronizedList的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-36-同步代码块与同步方法的区别" class="router-link-active router-link-exact-active toc-link level3">6.36 同步代码块与同步方法的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-37-set如何保证元素不重复" class="router-link-active router-link-exact-active toc-link level3">6.37 Set如何保证元素不重复？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-38-hashmap中的hash方法的原理" class="router-link-active router-link-exact-active toc-link level3">6.38 HashMap中的hash方法的原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-39-常见的hash函数" class="router-link-active router-link-exact-active toc-link level3">6.39 常见的hash函数</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-40-hashmap的数据结构" class="router-link-active router-link-exact-active toc-link level3">6.40 HashMap的数据结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-41-collection如何迭代" class="router-link-active router-link-exact-active toc-link level3">6.41 Collection如何迭代？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-42-enumeration和iterator的区别" class="router-link-active router-link-exact-active toc-link level3">6.42 Enumeration和Iterator的区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/md/interview/java/java-collection-01.html#_6-43-如何在遍历的同时删除arraylist的中的元素" class="router-link-active router-link-exact-active toc-link level3">6.43 如何在遍历的同时删除ArrayList的中的元素？</a></li><!----><!--]--></ul><!--]--></ul></div><!--[--><!----><!--]--></aside></div><!----><div class="theme-hope-content"><p>Java基础常见面试题-集合</p><!-- more --><h1 id="java集合常见面试题" tabindex="-1"><a class="header-anchor" href="#java集合常见面试题" aria-hidden="true">#</a> Java集合常见面试题</h1><h3 id="java中有哪些集合类" tabindex="-1"><a class="header-anchor" href="#java中有哪些集合类" aria-hidden="true">#</a> Java中有哪些集合类？</h3><p>Java中的集合类都是由Collection和Map派生的，其中Collection又派生了三个子接口，Set、List、Queue，因此可以将集合分为四大类：</p><ul><li>Set：代表无序，不可重复的集合</li><li>List：代表有序，可以重复的集合</li><li>Queue：代表先进先出队列</li><li>Map：代表具有映射关系的key-value集合</li></ul><p>Set接口常用实现类：HashSet，TreeSet等</p><p>List接口常用实现类：ArrayList、LinkedList等</p><p>Map接口常用实现类：HashMap、TreeMap、Hashtable、LinkedHashMap、Properties等</p><p>Queue接口又派生出一个Deque(代表双端队列)接口，常用的Deque接口实现类：LinkedList、ArrayDeque</p><h3 id="_6-2-集合类中线程安全与不安全的分别有哪些" tabindex="-1"><a class="header-anchor" href="#_6-2-集合类中线程安全与不安全的分别有哪些" aria-hidden="true">#</a> 6.2 集合类中线程安全与不安全的分别有哪些？</h3><p>在java.util包中，Vector、Hashtable是线程安全的，但是这两个类是古老的类，性能较差。除了Vector和Hashtable外，在java.util包中的其他集合类都是线程不安全的。</p><p>在JDK1.5后，在java.util.concurrent包下提供了大量支持高效并发访问的集合类，大致可分为两类：</p><ul><li>以Concurrent开头的集合类 <ul><li>代表了并发访问的集合，支持多线程并发访问，写操作都是线程安全的，这种集合类采用复杂的算法保证永远不会锁住整个集合，因此具有较好的性能</li></ul></li><li>CopyOnWrite开头的集合类 <ul><li>其底层的实现原理是采用复制数组的方式实现操作。对这种集合类进行读操作的时候，会读取原数组；进行写操作的时候，会复制一份新的数组，然后在复制的数组中进行写操作，因为在复制的数组中进行写操作，所以线程是安全的</li></ul></li></ul><h3 id="_6-3-map接口有哪些实现类" tabindex="-1"><a class="header-anchor" href="#_6-3-map接口有哪些实现类" aria-hidden="true">#</a> 6.3 Map接口有哪些实现类？</h3><p>常用的实现类：HashMap，LinkedHashMap，TreeMap，ConcurrentHashMap</p><p>对于不需要进行排序的场景，优先使用HashMap，它是性能最好的Map实现类，如果涉及到线程安全，则可以使用ConcurrentHashMap，它的性能好于Hashtable</p><p>对于需要进行排序的场景，如果需要按照插入的顺序进行排序，则可以使用LinkedHashMap；如果需要按照key自然进行排序，则可以使用TreeMap，如果涉及到线程安全，则可以使用Collections包装类</p><h3 id="_6-4-map-put的过程" tabindex="-1"><a class="header-anchor" href="#_6-4-map-put的过程" aria-hidden="true">#</a> 6.4 Map put的过程</h3><ul><li><p>首次扩容</p><ul><li>先判断数组是否为空，如果为空，则扩容</li></ul></li><li><p>计算索引</p><ul><li>通过hash算法计算需要添加的元素的key-value位置</li></ul></li><li><p>插入数据</p><ul><li>如果当前位置为空，则直接插入数据</li><li>如果当前位置不为空，且key不存在，则将数据链到链表末尾</li><li>如果当前位置不为空，且key存在，则将其value进行覆盖</li><li>如果链表的长度达到8，则将链表转为红黑树，并将数据插入到树中</li></ul></li><li><p>再次扩容</p><ul><li>如果数组中元素个数（size）超过threshold，则再次进行扩容</li></ul><p>具体过程图如下：</p><figure><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645688900795/18330EB2310CB83A25FA317E65ED60EB" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure></li></ul><h3 id="_6-5-如何得到一个线程安全的map" tabindex="-1"><a class="header-anchor" href="#_6-5-如何得到一个线程安全的map" aria-hidden="true">#</a> 6.5 如何得到一个线程安全的Map？</h3><ol><li>使用Collections类中Map的包装类</li><li>使用java.util.concurrent包下的Map类，如ConcurrentHashMap</li><li>使用Hashtable类，但是性能较差，不建议使用</li></ol><h3 id="_6-6-hashmap的特点" tabindex="-1"><a class="header-anchor" href="#_6-6-hashmap的特点" aria-hidden="true">#</a> 6.6 HashMap的特点？</h3><ol><li>是一个线程不安全的实现</li><li>可以使用null作为key或者value</li></ol><h3 id="_6-7-jdk7与jdk8之间的hashmap有什么区别" tabindex="-1"><a class="header-anchor" href="#_6-7-jdk7与jdk8之间的hashmap有什么区别" aria-hidden="true">#</a> 6.7 JDK7与JDK8之间的HashMap有什么区别？</h3><ul><li><p>在JDK7中HashMap的底层是数组+链表实现的，底层会维护一个Entry数组。它会通过hashCode来将对象的key-value存储到数组中，如果发生了hashCode冲突，则将该key-value存放在对应元素的后面，形成一个链表。当链表中存储的数据越来越多时，查询的效率就会变得很差。</p></li><li><p>在JDK8中HashMap的底层是数组+链表+红黑树实现的，底层维护一个Node数组。它会通过hashCode来将对象的key-value存储到数组中，如果发生了hashCode冲突，则将该key-value存放在对应元素的后面，形成一个链表，当链表中存储的数据个数大于等于8时，会将链表转换为红黑树进行存储。这么做的原因是在查询时优化时间复杂度，提高查找性能。</p></li></ul><h3 id="_6-8-arraylist与linkedlist的区别" tabindex="-1"><a class="header-anchor" href="#_6-8-arraylist与linkedlist的区别" aria-hidden="true">#</a> 6.8 ArrayList与LinkedList的区别？</h3><ul><li>ArrayList与LinkedList都实现了List接口，但是LinkedList多实现了一个Deque接口，所以LinkedList也可以当做队列使用</li><li>ArrayList与LinkedList的底层数据结构不同，ArrayList底层是基于动态数组实现的，而LinkedList是基于链表实现的</li><li>因为底层数据结构的不同，ArrayList与LinkedList的应用场景也不同，ArrayList更加适合查询数据，而LinkedList更加适合添加、删除、修改操作</li></ul><blockquote><p>ArrayList进行添加操作时，如果添加的位置有元素，那么该元素将后移，该元素后面的元素都向后移动，所以进行添加元素时，效率相对不高</p><p>LinkedList添加元素时，如果当前位置有元素，那么将遍历链表，找到指定位置的元素，然后添加，如果数据量较大，可能会遍历很多元素才能找到指定位置的元素，因此LinkedList在数据量不是很大时，添加操作的效率更高一些</p></blockquote><h3 id="_6-9-copyonwritearraylist的底层原理" tabindex="-1"><a class="header-anchor" href="#_6-9-copyonwritearraylist的底层原理" aria-hidden="true">#</a> 6.9 CopyOnWriteArrayList的底层原理</h3><ul><li>CopyOnWriteArrayList内部也是通过数组进行实现的，但是在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在复制的数组中进行，读操作在原数组中进行</li><li>在进行写操作时，会进行加锁，防止数据丢失</li><li>写操作结束后，会将原数组指向复制的新数组</li><li>CopyOnWriteArrayList允许在进行写操作时进行读数据，提高了读的性能，适合读多写少的场景，但是CopyOnWriteArrayList比较占用内存，同时读到的数据往往不是最新的数据，因此不适合对实时性要求较高的场景</li></ul><h3 id="_6-10-hashmap的底层实现原理" tabindex="-1"><a class="header-anchor" href="#_6-10-hashmap的底层实现原理" aria-hidden="true">#</a> 6.10 HashMap的底层实现原理</h3><p>基于hash算法，通过put和get方法存储和获取数据</p><p>存储对象时，将key-value传给put方法， 它通过hashCode获取hash值来确定存储的位置，然后进行存储。</p><p>获取对象是，将key传给get方法，它通过hashCode获取hash值来确定存储的位置，然后通过equals方法确定键值对</p><p>如果发生了hash冲突，则将其元素链接到链表的末尾，如果链表的长度超过了8，则将链表转为红黑树结构。</p><blockquote><p>HashMap 的数据是存储在链表数组里面的。在对 HashMap 进行插入/删除等操作时， 都需要根据 K-V 对的键值定位到他应该保存在数组的哪个下标中。而这个通过键值求取下 标的操作就叫做哈希。HashMap 的数组是有长度的，Java 中规定这个长度只能是 2 的倍 数，初始值为 16。简单的做法是先求取出键值的 hashcode，然后在将 hashcode 得到的 int 值对数组长度进行取模。为了考虑性能，Java 总采用按 位 与 操作实现取模操作</p></blockquote><h3 id="_6-11-hashmap的扩容机制" tabindex="-1"><a class="header-anchor" href="#_6-11-hashmap的扩容机制" aria-hidden="true">#</a> 6.11 HashMap的扩容机制</h3><p>HashMap的默认初始大小是16，当数组中的个数达到临界值（装载因子=0.75*最大容量）时会进行扩容，扩容大小都是成倍的，但是最大容量一直都是2的指数幂，所以说，每次扩容完的大小都是2的指数幂，比如说：当初始状态下达到12时，就会进行扩容，扩容后的大小是32。</p><blockquote><p>HashMap 作为一种数据结构，元素在 put 的过程中需要进行 hash 运算，目的是计 算出该元素存放在 hashMap 中的具体位置。 hash 运算的过程其实就是对目标元素的 Key 进行 hashcode，再对 Map 的容量进行 取模，而 JDK 的工程师为了提升取模的效率，使用位运算代替了取模运算，这就要求 Map 的容量一定得是 2 的幂。 而作为默认容量，太大和太小都不合适，所以 16 就作为一个比较合适的经验值被采用 了。 为了保证任何情况下 Map 的容量都是 2 的幂，HashMap 在两个地方都做了限制。 集合类 &lt; 164 首先是，如果用户制定了初始容量，那么 HashMap 会计算出比该数大的第一个 2 的 幂作为初始容量。 另外，在扩容的时候，也是进行成倍的扩容，即 4 变成 8，8 变成 16</p></blockquote><h3 id="_6-12-hashmap中循环链表如何产生" tabindex="-1"><a class="header-anchor" href="#_6-12-hashmap中循环链表如何产生" aria-hidden="true">#</a> 6.12 HashMap中循环链表如何产生？</h3><h3 id="_6-13-hashmap为什么是用红黑树-而不是b树" tabindex="-1"><a class="header-anchor" href="#_6-13-hashmap为什么是用红黑树-而不是b树" aria-hidden="true">#</a> 6.13 HashMap为什么是用红黑树，而不是B树？</h3><h3 id="_6-14-hashmap为什么线程不安全" tabindex="-1"><a class="header-anchor" href="#_6-14-hashmap为什么线程不安全" aria-hidden="true">#</a> 6.14 HashMap为什么线程不安全？</h3><p>HashMap在进行put操作的时候，可能会造成循环链表，也可能造成数据丢失</p><h3 id="_6-15-hashmap如何实现线程安全" tabindex="-1"><a class="header-anchor" href="#_6-15-hashmap如何实现线程安全" aria-hidden="true">#</a> 6.15 HashMap如何实现线程安全？</h3><ol><li>使用ConcurrentHashMap</li><li>使用Collections将HashMap包装成线程安全的类</li><li>使用Hashtable，因为版本太老，性能较差，一般不建议使用</li></ol><h3 id="_6-16-hashmap如何解决hash冲突的" tabindex="-1"><a class="header-anchor" href="#_6-16-hashmap如何解决hash冲突的" aria-hidden="true">#</a> 6.16 HashMap如何解决hash冲突的？</h3><p>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时，会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时，又会将红黑树转换回单向链表提高性能</p><blockquote><p>当发生哈希冲突后，HashMap会将冲突的元素直接添加在被冲突元素的后面，形成一个链表，当链表的长度超过或等于8时，将链表转换为红黑树的结构</p></blockquote><h3 id="_6-17-说一说hashmap和hashtable的区别" tabindex="-1"><a class="header-anchor" href="#_6-17-说一说hashmap和hashtable的区别" aria-hidden="true">#</a> 6.17 说一说HashMap和Hashtable的区别？</h3><ol><li><p>线程安全方面：Hashtable中的方法是同步的，HashMap是默认是不同步的</p></li><li><p>继承关系方面：HashMap继承与AbstractMap类，实现了Map接口；Hashtable继承了一个陈旧的类Dictionary</p></li><li><p>是否允许null值：HashMap允许使用null作为键和值，但是使用null作为键的时候只能存在一个；Hashtable不允许是null作为键和值</p></li><li><p>遍历方式：都采用了Iterator，但Hashtable还使用了Enumeration方式，Hashtable不支持快速失败（fast-fail），HashMap支持快速失败（fast-fail）</p></li><li><p>扩容机制：Hashtable初始大小是11，每次扩容为原来的2n+1，也就是说HashTable 的链表数组的默认大小是一个素数、奇数。之后的每次扩充结 果也都是奇数。；HashMap初始大小的16，每次扩容为原来的2倍</p><blockquote><p>当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀，所以单从这一 点上看，HashTable 的哈希表大小选择，似乎更高明些。因为 hash 结果越分散 效果越好</p><p>在取模计算时，如果模数是 2 的幂，那么我们可以直接使用位运算来得到结 果，效率要大大高于做除法。所以从 hash 计算的效率上，又是 HashMap 更胜一 筹。</p><p>但是，HashMap 为了提高效率使用位运算代替哈希，这又引入了哈希分布 不均匀的问题，所以 HashMap 为解决这问题，又对 hash 算法做了一些改进，进 行了扰动计算</p></blockquote></li></ol><p>哈希值的使用：Hashtable直接使用对象的hashCode，而HashMap需要重新计算hash值</p><h3 id="_6-18-hashmap与concurrenthashmap的区别" tabindex="-1"><a class="header-anchor" href="#_6-18-hashmap与concurrenthashmap的区别" aria-hidden="true">#</a> 6.18 HashMap与ConcurrentHashMap的区别？</h3><ol><li>HashMap是线程不安全的线程Map实现，而Concurrent是线程安全的Map实现</li><li>HashMap虽然可以使用Collections包装提供的包装类，但是其原理也是将所有功能的委托给Map，而包装类是基于synchronized关键字来确保线程安全的，底层是互斥锁，性能和吞吐量比较低</li><li>ConcurrentHashMap底层没有使用全局锁来锁住自己，尽可能的减少锁的竞争而导致阻塞和冲突，同时ConcurrentHashMap检索操作是不需要锁的</li></ol><h3 id="_6-19-concurrenthashmap是如何实现的" tabindex="-1"><a class="header-anchor" href="#_6-19-concurrenthashmap是如何实现的" aria-hidden="true">#</a> 6.19 ConcurrentHashMap是如何实现的？</h3><ol><li>JDK1.7时底层采用Segment数组+HashEntry数组+链表的分段锁技术，</li><li>JDK1.8时底层采用了Node数组+链表/红黑树的结构。当链表达到一定长度（8）时，链表会转换成红黑树；若减少元素，红黑树可以再次转换成链表</li><li>线程安全都是采用volatile修饰的自旋CAS操作</li><li>为了保证线程安全，ConcurrentHashMap主要变量都被volatile修饰。这些主要变量与HashMap中的主要变量的最大区别，ConcurrentHashMap有volatile修饰，才能保证线程安全性</li></ol><h3 id="_6-20-concurrenthashmap是如何分段分组的" tabindex="-1"><a class="header-anchor" href="#_6-20-concurrenthashmap是如何分段分组的" aria-hidden="true">#</a> 6.20 ConcurrentHashMap是如何分段分组的？</h3><h3 id="_6-21-说说你对linkedhashmap的理解" tabindex="-1"><a class="header-anchor" href="#_6-21-说说你对linkedhashmap的理解" aria-hidden="true">#</a> 6.21 说说你对LinkedHashMap的理解？</h3><ul><li>LinkedHashMap使用的是双向链表来维护key- value的，该链表只负责维护Map的迭代顺序，迭代顺序与key-value 的插入顺序保持一致</li><li>LinkedHashMap可以避免了对HashMap和Hashtable中的key-value进行排序（只需要插入key-value时保持顺序），同时又可以避免使用TreeMap所增加的成本</li><li>LinkedHashMap需要维护插入时的顺序，所以性能略低与HashMap，但是因为它以链表维护内部的顺序，所以在迭代访问Map里的全部元素时有较好的性能</li></ul><h3 id="_6-22-linkedhashmap的底层原理" tabindex="-1"><a class="header-anchor" href="#_6-22-linkedhashmap的底层原理" aria-hidden="true">#</a> 6.22 LinkedHashMap的底层原理</h3><ol><li><p>LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构。该结构由数组和链表+红黑树。在此基础上LinkedHashMap 增加了一条双向链表，保持遍历顺序和插入顺序一致的问题</p></li><li><p>在实现上，LinkedHashMap 很多方法直接继承自 HashMap（比如put remove方法就是直接用的父类的），仅为维护双向链表覆写了部分方法（get（）方法是重写的）</p></li><li><p>LinkedHashMap使用的键值对节点是Entity 他继承了hashMap 的Node,并新增了两个引用，分别是 before 和 after。这两个引用的用途不难理解，也就是用于维护双向链表</p></li><li><p>链表的建立过程是在插入键值对节点时开始的，初始情况下，让 LinkedHashMap 的 head 和 tail 引用同时指向新节点，链表就算建立起来了。随后不断有新节点插入，通过将新节点接在 tail 引用指向节点的后面，即可实现链表的更新</p></li><li><p>LinkedHashMap 允许使用null值和null键， 线程是不安全的，虽然底层使用了双线链表，但是增删相快了。因为他底层的Entity 保留了hashMap node 的next 属性</p></li></ol><h3 id="_6-23-treemap的底层原理" tabindex="-1"><a class="header-anchor" href="#_6-23-treemap的底层原理" aria-hidden="true">#</a> 6.23 TreeMap的底层原理</h3><ol><li><p>TreeMap实现了SortedMap接口，保证了有序性。默认的排序是根据key值进行升序排序，也可以重写comparator方法来根据value进行排序具体取决于使用的构造方法，不允许有null值null键，TreeMap是线程不安全的</p></li><li><p>TreeMap基于红黑树（Red-Black tree）实现。TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)</p></li></ol><h3 id="_6-24-map与set的区别" tabindex="-1"><a class="header-anchor" href="#_6-24-map与set的区别" aria-hidden="true">#</a> 6.24 Map与Set的区别？</h3><p>Set代表的是无序的，不可重复得集合</p><p>Map代表具有映射关系的key-value集合</p><p>Set继承自Collection接口，而Map自己就是顶级接口</p><h3 id="_6-25-list与set的区别" tabindex="-1"><a class="header-anchor" href="#_6-25-list与set的区别" aria-hidden="true">#</a> 6.25 List与Set的区别？</h3><ul><li><p>List代表的是有序的，可以重复的集合，按照对象进入的顺序保存对象，允许多个null元素对象，可以使用Iterator取出元素，然后遍历，也可以使用get获取指定下标的元素</p></li><li><p>Set代表的是无序的，不可重复得集合，允许一个null元素对象。取元素时只能用Iterator接口取的元素，逐一遍历</p></li></ul><h3 id="_6-26-有哪些线程安全的list" tabindex="-1"><a class="header-anchor" href="#_6-26-有哪些线程安全的list" aria-hidden="true">#</a> 6.26 有哪些线程安全的List？</h3><ol><li><p>直接实现类Vector，但是该类比较陈旧了，效率相对不高</p></li><li><p>java.util.concurrent包中的CobyOnWriteArrayList，通过复制的方法来实现线程安全</p></li><li><p>Collections类中将List包装成的SynchronizedList也是线程安全的类，但是Iterator没有加锁，所以在进行Iterator遍历的时候需要手动加锁</p></li></ol><h3 id="_6-27-arraylist的数据结构" tabindex="-1"><a class="header-anchor" href="#_6-27-arraylist的数据结构" aria-hidden="true">#</a> 6.27 ArrayList的数据结构</h3><ul><li><p>ArrayList底层是采用数组来进行数据的存储，数组元素的类型为Object类型，对ArrayList的所有操作底层都是基于数组的</p></li><li><p>对于随机访问的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据</p></li></ul><h3 id="_6-28-treeset与hashset的区别" tabindex="-1"><a class="header-anchor" href="#_6-28-treeset与hashset的区别" aria-hidden="true">#</a> 6.28 TreeSet与HashSet的区别？</h3><ol><li>TreeSet底层是TreeMap实现的 ，HashSet底层是HashMap实现的</li><li>TreeSet 是二叉树实现的，TreeSet中的数据是自动排好序的，不允许放入null值</li><li>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0</li><li>HashSet 是哈希表实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束。</li><li>HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的 String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例</li></ol><h3 id="_6-29-hashset的底层结构" tabindex="-1"><a class="header-anchor" href="#_6-29-hashset的底层结构" aria-hidden="true">#</a> 6.29 HashSet的底层结构</h3><ol><li>HashSet底层是直接调用HashMap类实现</li><li>HashMap的基本单元Entry对象是key-value，HashSet运用HashMap满足自身要求时，所有key对应的value都是用一个final的Object的</li><li>因为set里面是用的HashMap&lt;E,Object&gt; map，K, V要求是泛型所以必须传一个对象，这个Object字段是静态常量，set的每个元素都共享这个值，已经比较省空间了</li></ol><h3 id="_6-30-blockingqueue有哪些方法-为什么这样设计" tabindex="-1"><a class="header-anchor" href="#_6-30-blockingqueue有哪些方法-为什么这样设计" aria-hidden="true">#</a> 6.30 BlockingQueue有哪些方法？为什么这样设计？</h3><h3 id="_6-31-blockingqueue如何实现的" tabindex="-1"><a class="header-anchor" href="#_6-31-blockingqueue如何实现的" aria-hidden="true">#</a> 6.31 BlockingQueue如何实现的？</h3><h3 id="_6-32-stream-不是iostream-有哪些方法" tabindex="-1"><a class="header-anchor" href="#_6-32-stream-不是iostream-有哪些方法" aria-hidden="true">#</a> 6.32 Stream（不是IOStream）有哪些方法？</h3><h3 id="_6-33-vector和synchronizedlist的区别" tabindex="-1"><a class="header-anchor" href="#_6-33-vector和synchronizedlist的区别" aria-hidden="true">#</a> 6.33 Vector和SynchronizedList的区别？</h3><ol><li><p>SynchronizedList有很好的扩展和兼容功能，他可以将所有的 List 的子类转成线程安全的类。</p></li><li><p>使用 SynchronizedList的时候，进行遍历时要手动进行同步处理。</p></li><li><p>SynchronizedList可以指定锁定的对象</p></li></ol><p>Vector使用同步方法实现，而SynchronizedList通过同步代码块实现（SynchronizedList的方法基本上都是使用了同步代码块包上了List的方法）。</p><p>但是SynchronizedList 中实现的类并没有都使用 synchronized 同步代码块。其中有 listIterator 和 listIterator(int index)并没有做同步处理。但是 Vector 却对该方法加了方法锁。 所以说，在使用 SynchronizedList 进行遍历的时候要 手动加锁。</p><p>二者的扩容方式也不同（差别就和ArrayList和Vector的区别一样），Vector的扩容默认情况下是自动增长原来的一倍，而ArrayList是扩容原来的50%，所以得到的集合空间总是比实际的大。如果要在集合中保存大量数据，使用Vector会有一些优势（可以通过设置初始值大小来避免浪费资源）</p><blockquote><p>因为 SynchronizedList 只是使用同步代码块包裹了 ArrayList 的方法，而 ArrayList 和 Vector 中同名方法的方法体内容并无太大差异，所以在锁定范围和锁的作用域上两者并无却别。</p><p>但是在锁定的对象上有区别，SynchronizedList 的同步代码块锁定的是 mutex 对象， Vector 锁定的是 this 对象。SynchronizedList 有一 个构造函数可以传入一个 Object,如果在调用的时候显示的传入一个对象，那么锁定的就是 用户传入的对象。如果没有指定，那么锁定的也是 this 对象</p></blockquote><h3 id="_6-36-同步代码块与同步方法的区别" tabindex="-1"><a class="header-anchor" href="#_6-36-同步代码块与同步方法的区别" aria-hidden="true">#</a> 6.36 同步代码块与同步方法的区别？</h3><ol><li><p>同步代码块的锁的范围是比同步方法小的，一般来说锁的范围是于性能成反比的</p></li><li><p>同步代码块可以更加精确地控制锁的作用域（锁的作用域就是从锁被获取到其被释放的 时间），同步方法的锁的作用域就是整个方法</p></li><li><p>静态代码块可以选择对哪个对象加锁，但是静态方法只能给this对象加锁</p></li></ol><h3 id="_6-37-set如何保证元素不重复" tabindex="-1"><a class="header-anchor" href="#_6-37-set如何保证元素不重复" aria-hidden="true">#</a> 6.37 Set如何保证元素不重复？</h3><p>Set的实现可以分为两大类，分别是：HashSet和TreeSet</p><p>HashSet中，基本操作都是由HashMap底层实现的，因为HashSet底层是通过HashMap存储数据的。向HashSet中插入添加数据时，会计算出元素的hashcode，然后算出元素的存储位置，如果该位置为空，则直接添加，如果不为空，则通过equals方法比较元素是否相等，相等就不添加，不相等就找一个空位添加</p><p>TreeSet是通过key进行排序的，元素在插入TreeSet时compareTo方法要被调用，所以TreeSet的元素需要实Comparable接口，TreeSet是通过compareTo方法判断是否重复元素的</p><h3 id="_6-38-hashmap中的hash方法的原理" tabindex="-1"><a class="header-anchor" href="#_6-38-hashmap中的hash方法的原理" aria-hidden="true">#</a> 6.38 HashMap中的hash方法的原理</h3><h3 id="_6-39-常见的hash函数" tabindex="-1"><a class="header-anchor" href="#_6-39-常见的hash函数" aria-hidden="true">#</a> 6.39 常见的hash函数</h3><ul><li>直接定址法：直接以关键字k或者k加上某个常数（k + c）作为哈希地址</li><li>数字分析法：提取关键字中屈指比较均匀的数字作为哈希地址</li><li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得的余数作为哈希表地址</li><li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址</li><li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求去中间的几位作为哈希地址</li><li>伪随机数法：采用一个伪随机数当做哈希函数</li></ul><h3 id="_6-40-hashmap的数据结构" tabindex="-1"><a class="header-anchor" href="#_6-40-hashmap的数据结构" aria-hidden="true">#</a> 6.40 HashMap的数据结构</h3><blockquote><p>java中保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难，而链表的特点是：寻址困难，插入和删除容易。</p><p>常用的哈希函数的冲突解决办法中有一种犯法叫做链地址法，其实就是讲数组和链表组合在一起，发挥了两者的优势，我们可以将其理解为链表的数组。</p></blockquote><p>外表看似是一个数组，但是每个数组的成员是一个链表。这种数据结构所容纳的所有元素均好汉一个指针，用于元素见得连接诶。我们根据元素的自身特征把元素分配到不同的链表汇中去，反过来我们也是通过这些特征找到正确的链表，再从链表中找打正确的元素。其中根据元素特征计算元素数组下标的方法就是哈希算法，也就是hash()函数。</p><p>当我们要对一个链表数组中的某个 元素进行增删的时候，首先要知道他应该保存在这个链表数组中的哪个位置，即他在这个数 组中的下标。而 <code>hash()</code>方法的功能就是根据<code>Key</code>来定位其在<code>HashMap</code>中的位置。 <code>HashTable</code>、<code>ConcurrentHashMap</code> 同理。</p><h3 id="_6-41-collection如何迭代" tabindex="-1"><a class="header-anchor" href="#_6-41-collection如何迭代" aria-hidden="true">#</a> 6.41 Collection如何迭代？</h3><ol><li>通过普通for循环迭代</li><li>通过增强for循环迭代</li><li>使用Iterator迭代</li><li>使用Stream迭代</li></ol><h3 id="_6-42-enumeration和iterator的区别" tabindex="-1"><a class="header-anchor" href="#_6-42-enumeration和iterator的区别" aria-hidden="true">#</a> 6.42 Enumeration和Iterator的区别？</h3><ol><li>函数接口不同</li><li>Iterator支持fail-fast机制，而Enumeration不支持</li></ol><blockquote><p><strong>注意</strong>：Enumeration 迭代器只能遍历 Vector、Hashtable 这种古老的集合，因此通 常不要使用它，除非在某些极端情况下，不得不使用 Enumeration，否则都应该选择 Iterator 迭代器</p></blockquote><h3 id="_6-43-如何在遍历的同时删除arraylist的中的元素" tabindex="-1"><a class="header-anchor" href="#_6-43-如何在遍历的同时删除arraylist的中的元素" aria-hidden="true">#</a> 6.43 如何在遍历的同时删除ArrayList的中的元素？</h3><ol><li><p>直接使用普通for循环进行操作</p><ul><li>在foreach种不能进行，因为foreach中用到了Iterator比哪里，会导致fail-fast</li><li>但是可以使用普通for循环，因为普通for循环中没有用到Iterator遍历，不会导致fail-fast的检验</li><li>但是这种方案也存在一个问题，就是remove操作会改变List种元素的下标，可能存在漏删的情况</li></ul></li><li><p>直接使用Iterator进行操作</p><ul><li>直接使用Iterator提供的remove方法，还可以修改到expectedModCount的值，那么也就不会抛出异常了</li></ul></li><li><p>使用Java8种提供的filter过滤</p><ul><li>java8种可以把集合转换成流，对于流有一种filter操作，可以对原始Stream进行某项测试，通过测试的元素被留下来生成一个新的Stream</li></ul></li><li><p>使用增强for循环</p><ul><li>我们非常确定在一个集合中，某个即将删除的元素只包含一个的话， 比如对 Set 进行操作，那么其实也是可以使用增强 for 循环的，只要在删除之后，立刻结束循环体， 不要再继续进行遍历就可以了，也就是说不让代码执行到下一次的 next 方法</li></ul></li><li><p>直接使用fail-safe的集合类</p><ul><li>java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改</li></ul><blockquote><p>在 Java 中，除了一些普通地集合类以外，还有一些采用了 fail-safe 机制的集合类。 这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝 的集合上进行遍历。 由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能 被迭代器检测到，所以不会触发 ConcurrentModificationException。</p><p>基于拷贝内容的优点是避免了 ConcurrentModificationException，但同样地，迭代 器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍 历期间原集合发生的修改迭代器是不知道的</p></blockquote><h3 id="copyonwritearraylist比较与arraylist所具有的特性" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist比较与arraylist所具有的特性" aria-hidden="true">#</a> CopyOnWriteArrayList比较与ArrayList所具有的特性</h3><p>支持高效率并发且是线程安全的 因为通常需要复制整个基础数组，所以可变操作（ add()、set() 和 remove() 等等）的开销很大 迭代器支持 hasNext(), next()等不可变 操作，但不支持可变 remove()等操作 使用迭代器进行遍历的速度很快，并且不会与其他 线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照</p></li></ol><hr><h4 id="stream" tabindex="-1"><a class="header-anchor" href="#stream" aria-hidden="true">#</a> Stream</h4><p>Stream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象</p><p>Stream的特性和优点：</p><ul><li>无存储。Stream 不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一 个数组，Java 容器或 I/O channel 等</li><li>为函数式编程而生。对 Stream 的任何修改都不会修改背后的数据源，比如对 Stream 执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素 的新 Stream。</li><li>惰式执行。Stream 上的操作并不会立即执行，只有等到用户真正需要结果的时候才会 执行。</li><li>可消费性。Stream 只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那 样，想要再次遍历必须重新生成。</li></ul></div><!----><footer class="page-meta"><!----><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1727195232@qq.com">Fu Chen</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><a href="/md/interview/java/java-enum-01.html" class="nav-link prev" aria-label="Java枚举"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->Java枚举</div></a><!----></nav><!----><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer"><a href="https://beian.miit.gov.cn/#/Integrated/index">豫ICP备2023001076号-1</a></div><div class="copyright">Copyright © 2023 CY</div></footer></div><!--]--><!--]--><!----><!----><!--]--></div>
    <script type="module" src="/assets/app-40618983.js" defer></script>
  </body>
</html>
