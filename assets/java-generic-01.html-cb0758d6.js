import{_ as e,W as t,X as a,Y as i,Z as c,a0 as s}from"./framework-91490e6a.js";const d={},o=c("p",null,"Java基础常见面试题-泛型",-1),l=s('<h1 id="java泛型常见面试题" tabindex="-1"><a class="header-anchor" href="#java泛型常见面试题" aria-hidden="true">#</a> Java泛型常见面试题</h1><h3 id="泛型定义" tabindex="-1"><a class="header-anchor" href="#泛型定义" aria-hidden="true">#</a> 泛型定义</h3><p>Java 泛型（ generics） 是 JDK 5 中引⼊的⼀个新特性， 允许在定义类和接口的时候使⽤类型参数（ type parameter） 。 声明的类型参数在使⽤时⽤具体的类型来替换。 泛型最主要的应⽤是在 JDK 5 中的 新集合类框架中</p><p>泛型最⼤的好处是可以提⾼代码的复⽤性。 以 List 接口为例，我们可以将 String、 Integer 等类型放⼊List 中， 如不⽤泛型， 存放 String 类型要写⼀个 List 接口， 存放 Integer 要写另外⼀个 List 接口</p><div class="hint-container tip"><p class="hint-container-title">提示</p><ol><li>虚拟机中没有泛型，只有普通类和普通方法,所有泛型类的类型参数在编译时都会被 擦除,泛型类并没有自己独有的 Class 类对象。</li><li>创建泛型对象时请指明类型，让编译器尽早做参数检查（Effective Java，第23条：请不要在新代码中使用原生态类型）</li><li>不要忽略编译器的警告信息，那意味着潜在的ClassCastException等着你</li><li>静态变量是被泛型类的所有实例所共享的。对于声明为 MyClass的类，访问其中的 态变量的方法仍然是MyClass.myStaticVar。不管是通过new MyClass还是new MyClass创建的对象，都是共享一个静态变量</li><li>泛型的类型参数不能用在Java异常处理的catch语句中。因为异常处理是由JVM在运行时刻来进行的。由于类型信息被擦除，JVM 是无法区分两个异常类型<code>MyException&lt;A&gt;</code>和<code>MyException&lt;B&gt;</code>的。对于 JVM 来说，它们都是 MyException 类型的。也就无法执行与异常对应的 catch 语句</li></ol></div><h3 id="泛型k-t-v-e-object等的含义" tabindex="-1"><a class="header-anchor" href="#泛型k-t-v-e-object等的含义" aria-hidden="true">#</a> 泛型K T V E?object等的含义</h3><p>E - Element (在集合中使用，因为集合中存放的是元素)</p><p>T - Type（Java 类）</p><p>K - Key（键）</p><p>V - Value（值）</p><p>N - Number（数值类型）</p><p>？ - 表示不确定的 java 类型（无限制通配符类型）</p><p>S、U、V - 2nd、3rd、4th types</p><p>Object - 是所有类的根类，任何类的对象都可以设置给该 Object 引用变量，使用的 时候可能需要类型强制转换，但是用使用了泛型 T、E 等这些标识符后，在实际用之前类型 就已经确定了，不需要再进行类型强制转换</p><h3 id="限定通配符和非限定通配符" tabindex="-1"><a class="header-anchor" href="#限定通配符和非限定通配符" aria-hidden="true">#</a> 限定通配符和非限定通配符</h3><p>限定通配符对类型进⾏限制， 泛型中有两种限定通配符：</p><p>表示类型的上界，格式为：&lt;？ extends T&gt;，即类型必须为T类型或者T的子类</p><p>表示类型的下界，格式为：&lt;？ super T&gt;，即类型必须为 T类或T的父类</p><p>泛型类型必须⽤限定内的类型来进⾏初始化，否则会导致编译错误</p><p>⾮限定通配符表示可以⽤任意泛型类型来替代，类型为&lt; T &gt;</p><h3 id="list-object-和原始类型list之间的区别" tabindex="-1"><a class="header-anchor" href="#list-object-和原始类型list之间的区别" aria-hidden="true">#</a> <code>List&lt;Object&gt;</code>和原始类型List之间的区别</h3><p>原始类型List和带参数类型<code>List&lt;Object&gt;</code>之间的主要区别是，在编译时编译器不会对原始类型进行类型安全检查，却会对带参数的类型进行检查</p><p>通过使用Object作为类型，可以告知编译器该方法可以接受任何类型的对象，比如String或Integer</p><p>它们之间的第二点区别是，你可以把任何带参数的类型传递给原始类型List，但却不能把<code>List&lt;String&gt;</code>传递给接受<code>List&lt;Object&gt;</code>的方法，因为会产生编译错误</p><h3 id="list-和list-object-之间的区别是什么" tabindex="-1"><a class="header-anchor" href="#list-和list-object-之间的区别是什么" aria-hidden="true">#</a> <code>List&lt;?&gt;</code>和<code>List&lt;Object&gt;</code>之间的区别是什么？</h3><p><code>List&lt;?&gt;</code> 是一个未知类型的List，而<code>List&lt;Object&gt;</code>其实是任意类型的List。你可以把 <code>List&lt;String&gt;</code>, <code>List&lt;Integer&gt;</code>赋值给 <code>List&lt;?&gt;</code>，却不能把 <code>List&lt;?&gt;</code>赋值给 <code>List&lt;Object&gt;</code></p>',26);function r(n,p){return t(),a("div",null,[o,i(" more "),l])}const g=e(d,[["render",r],["__file","java-generic-01.html.vue"]]);export{g as default};
