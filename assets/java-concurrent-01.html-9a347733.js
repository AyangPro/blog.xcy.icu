import{_ as a,W as e,X as l,Y as r,Z as i,a0 as c}from"./framework-91490e6a.js";const d={},h=i("p",null,"Java基础常见面试题-并发",-1),o=c('<h1 id="java并发常见面试题" tabindex="-1"><a class="header-anchor" href="#java并发常见面试题" aria-hidden="true">#</a> Java并发常见面试题</h1><h3 id="线程池如何实现复用的" tabindex="-1"><a class="header-anchor" href="#线程池如何实现复用的" aria-hidden="true">#</a> 线程池如何实现复用的？</h3><p>1、当Thread的run方法执行完一个任务之后，会循环地从阻塞队列中取任务来执行，这样执行完一个任务之后就不会立即销毁了； 2、当工作线程数小于核心线程数，那些空闲的核心线程再去队列取任务的时候，如果队列中的Runnable数量为0，就会阻塞当前线程，这样线程就不会回收了</p><h3 id="threadlocal" tabindex="-1"><a class="header-anchor" href="#threadlocal" aria-hidden="true">#</a> ThreadLocal</h3><ol><li><p>ThreadLocal是java中所提供的线程本地存储机制，可以利用该机制将数据缓存在某个线程内部，该线程可以在任意时刻，任意方法中获取缓存数据</p></li><li><p>ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象(注意不是ThreadLocal对象)中都存在一个ThreadLocalMap，Map的key为ThreadLocal对象，Map的value为需要缓存的值</p></li><li><p>如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用完之后，应该要把设置的key, value，也就是Entry对象进行回收，但线程池中的线程不会回收，而线程对象是通过强引用指向ThreadLocalMap，ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象也就不会被回收，从而出现内存泄漏，解决办法是，在使用了ThreadLocal对象之后，手动调用ThreadLocal的remove方法，手动清楚Entry对象</p></li><li><p>ThreadLocal经典的应用场景就是连接管理（一个线程持有一个连接，该连接对象可以在不同的方法之间进行传递，线程之间不共享同一个连接)</p></li></ol><h3 id="线程池的七个参数" tabindex="-1"><a class="header-anchor" href="#线程池的七个参数" aria-hidden="true">#</a> 线程池的七个参数</h3><ul><li>核心线程数</li></ul><p>线程池维护的最小线程数量，核心线程创建后不会被回收，空闲的核心线程超过存活时间也会被回收</p><p>大于核心线程数的线程，在空闲时间超过keepAliveTime后会被回收</p><p>线程池刚创建时，里面没有一个线程，当调用 execute() 方法添加一个任务时，如果正在运行的线程数量小于corePoolSize，则马上创建新线程并运行这个任务。</p><p>线程池允许创建的最大线程数量。</p><p>当添加一个任务时，核心线程数已满，线程池还没达到最大线程数，并且没有空闲线程，工作队列已满的情况下，创建一个新线程并执行。</p><ul><li>最大线程数</li><li>空闲线程存活时间</li><li>时间单位</li><li>工作队列</li><li>线程工厂</li><li>拒绝策略</li></ul>',13);function t(n,p){return e(),l("div",null,[h,r(" more "),o])}const u=a(d,[["render",t],["__file","java-concurrent-01.html.vue"]]);export{u as default};
