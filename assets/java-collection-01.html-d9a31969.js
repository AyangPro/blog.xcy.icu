import{_ as a,W as e,X as i,Y as h,Z as r,a0 as l}from"./framework-91490e6a.js";const t={},s=r("p",null,"Java基础常见面试题-集合",-1),p=l('<h1 id="java集合常见面试题" tabindex="-1"><a class="header-anchor" href="#java集合常见面试题" aria-hidden="true">#</a> Java集合常见面试题</h1><h3 id="java中有哪些集合类" tabindex="-1"><a class="header-anchor" href="#java中有哪些集合类" aria-hidden="true">#</a> Java中有哪些集合类？</h3><p>Java中的集合类都是由Collection和Map派生的，其中Collection又派生了三个子接口，Set、List、Queue，因此可以将集合分为四大类：</p><ul><li>Set：代表无序，不可重复的集合</li><li>List：代表有序，可以重复的集合</li><li>Queue：代表先进先出队列</li><li>Map：代表具有映射关系的key-value集合</li></ul><p>Set接口常用实现类：HashSet，TreeSet等</p><p>List接口常用实现类：ArrayList、LinkedList等</p><p>Map接口常用实现类：HashMap、TreeMap、Hashtable、LinkedHashMap、Properties等</p><p>Queue接口又派生出一个Deque(代表双端队列)接口，常用的Deque接口实现类：LinkedList、ArrayDeque</p><h3 id="_6-2-集合类中线程安全与不安全的分别有哪些" tabindex="-1"><a class="header-anchor" href="#_6-2-集合类中线程安全与不安全的分别有哪些" aria-hidden="true">#</a> 6.2 集合类中线程安全与不安全的分别有哪些？</h3><p>在java.util包中，Vector、Hashtable是线程安全的，但是这两个类是古老的类，性能较差。除了Vector和Hashtable外，在java.util包中的其他集合类都是线程不安全的。</p><p>在JDK1.5后，在java.util.concurrent包下提供了大量支持高效并发访问的集合类，大致可分为两类：</p><ul><li>以Concurrent开头的集合类 <ul><li>代表了并发访问的集合，支持多线程并发访问，写操作都是线程安全的，这种集合类采用复杂的算法保证永远不会锁住整个集合，因此具有较好的性能</li></ul></li><li>CopyOnWrite开头的集合类 <ul><li>其底层的实现原理是采用复制数组的方式实现操作。对这种集合类进行读操作的时候，会读取原数组；进行写操作的时候，会复制一份新的数组，然后在复制的数组中进行写操作，因为在复制的数组中进行写操作，所以线程是安全的</li></ul></li></ul><h3 id="_6-3-map接口有哪些实现类" tabindex="-1"><a class="header-anchor" href="#_6-3-map接口有哪些实现类" aria-hidden="true">#</a> 6.3 Map接口有哪些实现类？</h3><p>常用的实现类：HashMap，LinkedHashMap，TreeMap，ConcurrentHashMap</p><p>对于不需要进行排序的场景，优先使用HashMap，它是性能最好的Map实现类，如果涉及到线程安全，则可以使用ConcurrentHashMap，它的性能好于Hashtable</p><p>对于需要进行排序的场景，如果需要按照插入的顺序进行排序，则可以使用LinkedHashMap；如果需要按照key自然进行排序，则可以使用TreeMap，如果涉及到线程安全，则可以使用Collections包装类</p><h3 id="_6-4-map-put的过程" tabindex="-1"><a class="header-anchor" href="#_6-4-map-put的过程" aria-hidden="true">#</a> 6.4 Map put的过程</h3><ul><li><p>首次扩容</p><ul><li>先判断数组是否为空，如果为空，则扩容</li></ul></li><li><p>计算索引</p><ul><li>通过hash算法计算需要添加的元素的key-value位置</li></ul></li><li><p>插入数据</p><ul><li>如果当前位置为空，则直接插入数据</li><li>如果当前位置不为空，且key不存在，则将数据链到链表末尾</li><li>如果当前位置不为空，且key存在，则将其value进行覆盖</li><li>如果链表的长度达到8，则将链表转为红黑树，并将数据插入到树中</li></ul></li><li><p>再次扩容</p><ul><li>如果数组中元素个数（size）超过threshold，则再次进行扩容</li></ul><p>具体过程图如下：</p><figure><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645688900795/18330EB2310CB83A25FA317E65ED60EB" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure></li></ul><h3 id="_6-5-如何得到一个线程安全的map" tabindex="-1"><a class="header-anchor" href="#_6-5-如何得到一个线程安全的map" aria-hidden="true">#</a> 6.5 如何得到一个线程安全的Map？</h3><ol><li>使用Collections类中Map的包装类</li><li>使用java.util.concurrent包下的Map类，如ConcurrentHashMap</li><li>使用Hashtable类，但是性能较差，不建议使用</li></ol><h3 id="_6-6-hashmap的特点" tabindex="-1"><a class="header-anchor" href="#_6-6-hashmap的特点" aria-hidden="true">#</a> 6.6 HashMap的特点？</h3><ol><li>是一个线程不安全的实现</li><li>可以使用null作为key或者value</li></ol><h3 id="_6-7-jdk7与jdk8之间的hashmap有什么区别" tabindex="-1"><a class="header-anchor" href="#_6-7-jdk7与jdk8之间的hashmap有什么区别" aria-hidden="true">#</a> 6.7 JDK7与JDK8之间的HashMap有什么区别？</h3><ul><li><p>在JDK7中HashMap的底层是数组+链表实现的，底层会维护一个Entry数组。它会通过hashCode来将对象的key-value存储到数组中，如果发生了hashCode冲突，则将该key-value存放在对应元素的后面，形成一个链表。当链表中存储的数据越来越多时，查询的效率就会变得很差。</p></li><li><p>在JDK8中HashMap的底层是数组+链表+红黑树实现的，底层维护一个Node数组。它会通过hashCode来将对象的key-value存储到数组中，如果发生了hashCode冲突，则将该key-value存放在对应元素的后面，形成一个链表，当链表中存储的数据个数大于等于8时，会将链表转换为红黑树进行存储。这么做的原因是在查询时优化时间复杂度，提高查找性能。</p></li></ul><h3 id="_6-8-arraylist与linkedlist的区别" tabindex="-1"><a class="header-anchor" href="#_6-8-arraylist与linkedlist的区别" aria-hidden="true">#</a> 6.8 ArrayList与LinkedList的区别？</h3><ul><li>ArrayList与LinkedList都实现了List接口，但是LinkedList多实现了一个Deque接口，所以LinkedList也可以当做队列使用</li><li>ArrayList与LinkedList的底层数据结构不同，ArrayList底层是基于动态数组实现的，而LinkedList是基于链表实现的</li><li>因为底层数据结构的不同，ArrayList与LinkedList的应用场景也不同，ArrayList更加适合查询数据，而LinkedList更加适合添加、删除、修改操作</li></ul><blockquote><p>ArrayList进行添加操作时，如果添加的位置有元素，那么该元素将后移，该元素后面的元素都向后移动，所以进行添加元素时，效率相对不高</p><p>LinkedList添加元素时，如果当前位置有元素，那么将遍历链表，找到指定位置的元素，然后添加，如果数据量较大，可能会遍历很多元素才能找到指定位置的元素，因此LinkedList在数据量不是很大时，添加操作的效率更高一些</p></blockquote><h3 id="_6-9-copyonwritearraylist的底层原理" tabindex="-1"><a class="header-anchor" href="#_6-9-copyonwritearraylist的底层原理" aria-hidden="true">#</a> 6.9 CopyOnWriteArrayList的底层原理</h3><ul><li>CopyOnWriteArrayList内部也是通过数组进行实现的，但是在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在复制的数组中进行，读操作在原数组中进行</li><li>在进行写操作时，会进行加锁，防止数据丢失</li><li>写操作结束后，会将原数组指向复制的新数组</li><li>CopyOnWriteArrayList允许在进行写操作时进行读数据，提高了读的性能，适合读多写少的场景，但是CopyOnWriteArrayList比较占用内存，同时读到的数据往往不是最新的数据，因此不适合对实时性要求较高的场景</li></ul><h3 id="_6-10-hashmap的底层实现原理" tabindex="-1"><a class="header-anchor" href="#_6-10-hashmap的底层实现原理" aria-hidden="true">#</a> 6.10 HashMap的底层实现原理</h3><p>基于hash算法，通过put和get方法存储和获取数据</p><p>存储对象时，将key-value传给put方法， 它通过hashCode获取hash值来确定存储的位置，然后进行存储。</p><p>获取对象是，将key传给get方法，它通过hashCode获取hash值来确定存储的位置，然后通过equals方法确定键值对</p><p>如果发生了hash冲突，则将其元素链接到链表的末尾，如果链表的长度超过了8，则将链表转为红黑树结构。</p><blockquote><p>HashMap 的数据是存储在链表数组里面的。在对 HashMap 进行插入/删除等操作时， 都需要根据 K-V 对的键值定位到他应该保存在数组的哪个下标中。而这个通过键值求取下 标的操作就叫做哈希。HashMap 的数组是有长度的，Java 中规定这个长度只能是 2 的倍 数，初始值为 16。简单的做法是先求取出键值的 hashcode，然后在将 hashcode 得到的 int 值对数组长度进行取模。为了考虑性能，Java 总采用按 位 与 操作实现取模操作</p></blockquote><h3 id="_6-11-hashmap的扩容机制" tabindex="-1"><a class="header-anchor" href="#_6-11-hashmap的扩容机制" aria-hidden="true">#</a> 6.11 HashMap的扩容机制</h3><p>HashMap的默认初始大小是16，当数组中的个数达到临界值（装载因子=0.75*最大容量）时会进行扩容，扩容大小都是成倍的，但是最大容量一直都是2的指数幂，所以说，每次扩容完的大小都是2的指数幂，比如说：当初始状态下达到12时，就会进行扩容，扩容后的大小是32。</p><blockquote><p>HashMap 作为一种数据结构，元素在 put 的过程中需要进行 hash 运算，目的是计 算出该元素存放在 hashMap 中的具体位置。 hash 运算的过程其实就是对目标元素的 Key 进行 hashcode，再对 Map 的容量进行 取模，而 JDK 的工程师为了提升取模的效率，使用位运算代替了取模运算，这就要求 Map 的容量一定得是 2 的幂。 而作为默认容量，太大和太小都不合适，所以 16 就作为一个比较合适的经验值被采用 了。 为了保证任何情况下 Map 的容量都是 2 的幂，HashMap 在两个地方都做了限制。 集合类 &lt; 164 首先是，如果用户制定了初始容量，那么 HashMap 会计算出比该数大的第一个 2 的 幂作为初始容量。 另外，在扩容的时候，也是进行成倍的扩容，即 4 变成 8，8 变成 16</p></blockquote><h3 id="_6-12-hashmap中循环链表如何产生" tabindex="-1"><a class="header-anchor" href="#_6-12-hashmap中循环链表如何产生" aria-hidden="true">#</a> 6.12 HashMap中循环链表如何产生？</h3><h3 id="_6-13-hashmap为什么是用红黑树-而不是b树" tabindex="-1"><a class="header-anchor" href="#_6-13-hashmap为什么是用红黑树-而不是b树" aria-hidden="true">#</a> 6.13 HashMap为什么是用红黑树，而不是B树？</h3><h3 id="_6-14-hashmap为什么线程不安全" tabindex="-1"><a class="header-anchor" href="#_6-14-hashmap为什么线程不安全" aria-hidden="true">#</a> 6.14 HashMap为什么线程不安全？</h3><p>HashMap在进行put操作的时候，可能会造成循环链表，也可能造成数据丢失</p><h3 id="_6-15-hashmap如何实现线程安全" tabindex="-1"><a class="header-anchor" href="#_6-15-hashmap如何实现线程安全" aria-hidden="true">#</a> 6.15 HashMap如何实现线程安全？</h3><ol><li>使用ConcurrentHashMap</li><li>使用Collections将HashMap包装成线程安全的类</li><li>使用Hashtable，因为版本太老，性能较差，一般不建议使用</li></ol><h3 id="_6-16-hashmap如何解决hash冲突的" tabindex="-1"><a class="header-anchor" href="#_6-16-hashmap如何解决hash冲突的" aria-hidden="true">#</a> 6.16 HashMap如何解决hash冲突的？</h3><p>为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值时，会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值时，又会将红黑树转换回单向链表提高性能</p><blockquote><p>当发生哈希冲突后，HashMap会将冲突的元素直接添加在被冲突元素的后面，形成一个链表，当链表的长度超过或等于8时，将链表转换为红黑树的结构</p></blockquote><h3 id="_6-17-说一说hashmap和hashtable的区别" tabindex="-1"><a class="header-anchor" href="#_6-17-说一说hashmap和hashtable的区别" aria-hidden="true">#</a> 6.17 说一说HashMap和Hashtable的区别？</h3><ol><li><p>线程安全方面：Hashtable中的方法是同步的，HashMap是默认是不同步的</p></li><li><p>继承关系方面：HashMap继承与AbstractMap类，实现了Map接口；Hashtable继承了一个陈旧的类Dictionary</p></li><li><p>是否允许null值：HashMap允许使用null作为键和值，但是使用null作为键的时候只能存在一个；Hashtable不允许是null作为键和值</p></li><li><p>遍历方式：都采用了Iterator，但Hashtable还使用了Enumeration方式，Hashtable不支持快速失败（fast-fail），HashMap支持快速失败（fast-fail）</p></li><li><p>扩容机制：Hashtable初始大小是11，每次扩容为原来的2n+1，也就是说HashTable 的链表数组的默认大小是一个素数、奇数。之后的每次扩充结 果也都是奇数。；HashMap初始大小的16，每次扩容为原来的2倍</p><blockquote><p>当哈希表的大小为素数时，简单的取模哈希的结果会更加均匀，所以单从这一 点上看，HashTable 的哈希表大小选择，似乎更高明些。因为 hash 结果越分散 效果越好</p><p>在取模计算时，如果模数是 2 的幂，那么我们可以直接使用位运算来得到结 果，效率要大大高于做除法。所以从 hash 计算的效率上，又是 HashMap 更胜一 筹。</p><p>但是，HashMap 为了提高效率使用位运算代替哈希，这又引入了哈希分布 不均匀的问题，所以 HashMap 为解决这问题，又对 hash 算法做了一些改进，进 行了扰动计算</p></blockquote></li></ol><p>哈希值的使用：Hashtable直接使用对象的hashCode，而HashMap需要重新计算hash值</p><h3 id="_6-18-hashmap与concurrenthashmap的区别" tabindex="-1"><a class="header-anchor" href="#_6-18-hashmap与concurrenthashmap的区别" aria-hidden="true">#</a> 6.18 HashMap与ConcurrentHashMap的区别？</h3><ol><li>HashMap是线程不安全的线程Map实现，而Concurrent是线程安全的Map实现</li><li>HashMap虽然可以使用Collections包装提供的包装类，但是其原理也是将所有功能的委托给Map，而包装类是基于synchronized关键字来确保线程安全的，底层是互斥锁，性能和吞吐量比较低</li><li>ConcurrentHashMap底层没有使用全局锁来锁住自己，尽可能的减少锁的竞争而导致阻塞和冲突，同时ConcurrentHashMap检索操作是不需要锁的</li></ol><h3 id="_6-19-concurrenthashmap是如何实现的" tabindex="-1"><a class="header-anchor" href="#_6-19-concurrenthashmap是如何实现的" aria-hidden="true">#</a> 6.19 ConcurrentHashMap是如何实现的？</h3><ol><li>JDK1.7时底层采用Segment数组+HashEntry数组+链表的分段锁技术，</li><li>JDK1.8时底层采用了Node数组+链表/红黑树的结构。当链表达到一定长度（8）时，链表会转换成红黑树；若减少元素，红黑树可以再次转换成链表</li><li>线程安全都是采用volatile修饰的自旋CAS操作</li><li>为了保证线程安全，ConcurrentHashMap主要变量都被volatile修饰。这些主要变量与HashMap中的主要变量的最大区别，ConcurrentHashMap有volatile修饰，才能保证线程安全性</li></ol><h3 id="_6-20-concurrenthashmap是如何分段分组的" tabindex="-1"><a class="header-anchor" href="#_6-20-concurrenthashmap是如何分段分组的" aria-hidden="true">#</a> 6.20 ConcurrentHashMap是如何分段分组的？</h3><h3 id="_6-21-说说你对linkedhashmap的理解" tabindex="-1"><a class="header-anchor" href="#_6-21-说说你对linkedhashmap的理解" aria-hidden="true">#</a> 6.21 说说你对LinkedHashMap的理解？</h3><ul><li>LinkedHashMap使用的是双向链表来维护key- value的，该链表只负责维护Map的迭代顺序，迭代顺序与key-value 的插入顺序保持一致</li><li>LinkedHashMap可以避免了对HashMap和Hashtable中的key-value进行排序（只需要插入key-value时保持顺序），同时又可以避免使用TreeMap所增加的成本</li><li>LinkedHashMap需要维护插入时的顺序，所以性能略低与HashMap，但是因为它以链表维护内部的顺序，所以在迭代访问Map里的全部元素时有较好的性能</li></ul><h3 id="_6-22-linkedhashmap的底层原理" tabindex="-1"><a class="header-anchor" href="#_6-22-linkedhashmap的底层原理" aria-hidden="true">#</a> 6.22 LinkedHashMap的底层原理</h3><ol><li><p>LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构。该结构由数组和链表+红黑树。在此基础上LinkedHashMap 增加了一条双向链表，保持遍历顺序和插入顺序一致的问题</p></li><li><p>在实现上，LinkedHashMap 很多方法直接继承自 HashMap（比如put remove方法就是直接用的父类的），仅为维护双向链表覆写了部分方法（get（）方法是重写的）</p></li><li><p>LinkedHashMap使用的键值对节点是Entity 他继承了hashMap 的Node,并新增了两个引用，分别是 before 和 after。这两个引用的用途不难理解，也就是用于维护双向链表</p></li><li><p>链表的建立过程是在插入键值对节点时开始的，初始情况下，让 LinkedHashMap 的 head 和 tail 引用同时指向新节点，链表就算建立起来了。随后不断有新节点插入，通过将新节点接在 tail 引用指向节点的后面，即可实现链表的更新</p></li><li><p>LinkedHashMap 允许使用null值和null键， 线程是不安全的，虽然底层使用了双线链表，但是增删相快了。因为他底层的Entity 保留了hashMap node 的next 属性</p></li></ol><h3 id="_6-23-treemap的底层原理" tabindex="-1"><a class="header-anchor" href="#_6-23-treemap的底层原理" aria-hidden="true">#</a> 6.23 TreeMap的底层原理</h3><ol><li><p>TreeMap实现了SortedMap接口，保证了有序性。默认的排序是根据key值进行升序排序，也可以重写comparator方法来根据value进行排序具体取决于使用的构造方法，不允许有null值null键，TreeMap是线程不安全的</p></li><li><p>TreeMap基于红黑树（Red-Black tree）实现。TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n)</p></li></ol><h3 id="_6-24-map与set的区别" tabindex="-1"><a class="header-anchor" href="#_6-24-map与set的区别" aria-hidden="true">#</a> 6.24 Map与Set的区别？</h3><p>Set代表的是无序的，不可重复得集合</p><p>Map代表具有映射关系的key-value集合</p><p>Set继承自Collection接口，而Map自己就是顶级接口</p><h3 id="_6-25-list与set的区别" tabindex="-1"><a class="header-anchor" href="#_6-25-list与set的区别" aria-hidden="true">#</a> 6.25 List与Set的区别？</h3><ul><li><p>List代表的是有序的，可以重复的集合，按照对象进入的顺序保存对象，允许多个null元素对象，可以使用Iterator取出元素，然后遍历，也可以使用get获取指定下标的元素</p></li><li><p>Set代表的是无序的，不可重复得集合，允许一个null元素对象。取元素时只能用Iterator接口取的元素，逐一遍历</p></li></ul><h3 id="_6-26-有哪些线程安全的list" tabindex="-1"><a class="header-anchor" href="#_6-26-有哪些线程安全的list" aria-hidden="true">#</a> 6.26 有哪些线程安全的List？</h3><ol><li><p>直接实现类Vector，但是该类比较陈旧了，效率相对不高</p></li><li><p>java.util.concurrent包中的CobyOnWriteArrayList，通过复制的方法来实现线程安全</p></li><li><p>Collections类中将List包装成的SynchronizedList也是线程安全的类，但是Iterator没有加锁，所以在进行Iterator遍历的时候需要手动加锁</p></li></ol><h3 id="_6-27-arraylist的数据结构" tabindex="-1"><a class="header-anchor" href="#_6-27-arraylist的数据结构" aria-hidden="true">#</a> 6.27 ArrayList的数据结构</h3><ul><li><p>ArrayList底层是采用数组来进行数据的存储，数组元素的类型为Object类型，对ArrayList的所有操作底层都是基于数组的</p></li><li><p>对于随机访问的get和set方法，ArrayList要优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据</p></li></ul><h3 id="_6-28-treeset与hashset的区别" tabindex="-1"><a class="header-anchor" href="#_6-28-treeset与hashset的区别" aria-hidden="true">#</a> 6.28 TreeSet与HashSet的区别？</h3><ol><li>TreeSet底层是TreeMap实现的 ，HashSet底层是HashMap实现的</li><li>TreeSet 是二叉树实现的，TreeSet中的数据是自动排好序的，不允许放入null值</li><li>TreeSet判断两个对象不相等的方式是两个对象通过equals方法返回false，或者通过CompareTo方法比较没有返回0</li><li>HashSet 是哈希表实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束。</li><li>HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的 String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例</li></ol><h3 id="_6-29-hashset的底层结构" tabindex="-1"><a class="header-anchor" href="#_6-29-hashset的底层结构" aria-hidden="true">#</a> 6.29 HashSet的底层结构</h3><ol><li>HashSet底层是直接调用HashMap类实现</li><li>HashMap的基本单元Entry对象是key-value，HashSet运用HashMap满足自身要求时，所有key对应的value都是用一个final的Object的</li><li>因为set里面是用的HashMap&lt;E,Object&gt; map，K, V要求是泛型所以必须传一个对象，这个Object字段是静态常量，set的每个元素都共享这个值，已经比较省空间了</li></ol><h3 id="_6-30-blockingqueue有哪些方法-为什么这样设计" tabindex="-1"><a class="header-anchor" href="#_6-30-blockingqueue有哪些方法-为什么这样设计" aria-hidden="true">#</a> 6.30 BlockingQueue有哪些方法？为什么这样设计？</h3><h3 id="_6-31-blockingqueue如何实现的" tabindex="-1"><a class="header-anchor" href="#_6-31-blockingqueue如何实现的" aria-hidden="true">#</a> 6.31 BlockingQueue如何实现的？</h3><h3 id="_6-32-stream-不是iostream-有哪些方法" tabindex="-1"><a class="header-anchor" href="#_6-32-stream-不是iostream-有哪些方法" aria-hidden="true">#</a> 6.32 Stream（不是IOStream）有哪些方法？</h3><h3 id="_6-33-vector和synchronizedlist的区别" tabindex="-1"><a class="header-anchor" href="#_6-33-vector和synchronizedlist的区别" aria-hidden="true">#</a> 6.33 Vector和SynchronizedList的区别？</h3><ol><li><p>SynchronizedList有很好的扩展和兼容功能，他可以将所有的 List 的子类转成线程安全的类。</p></li><li><p>使用 SynchronizedList的时候，进行遍历时要手动进行同步处理。</p></li><li><p>SynchronizedList可以指定锁定的对象</p></li></ol><p>Vector使用同步方法实现，而SynchronizedList通过同步代码块实现（SynchronizedList的方法基本上都是使用了同步代码块包上了List的方法）。</p><p>但是SynchronizedList 中实现的类并没有都使用 synchronized 同步代码块。其中有 listIterator 和 listIterator(int index)并没有做同步处理。但是 Vector 却对该方法加了方法锁。 所以说，在使用 SynchronizedList 进行遍历的时候要 手动加锁。</p><p>二者的扩容方式也不同（差别就和ArrayList和Vector的区别一样），Vector的扩容默认情况下是自动增长原来的一倍，而ArrayList是扩容原来的50%，所以得到的集合空间总是比实际的大。如果要在集合中保存大量数据，使用Vector会有一些优势（可以通过设置初始值大小来避免浪费资源）</p><blockquote><p>因为 SynchronizedList 只是使用同步代码块包裹了 ArrayList 的方法，而 ArrayList 和 Vector 中同名方法的方法体内容并无太大差异，所以在锁定范围和锁的作用域上两者并无却别。</p><p>但是在锁定的对象上有区别，SynchronizedList 的同步代码块锁定的是 mutex 对象， Vector 锁定的是 this 对象。SynchronizedList 有一 个构造函数可以传入一个 Object,如果在调用的时候显示的传入一个对象，那么锁定的就是 用户传入的对象。如果没有指定，那么锁定的也是 this 对象</p></blockquote><h3 id="_6-36-同步代码块与同步方法的区别" tabindex="-1"><a class="header-anchor" href="#_6-36-同步代码块与同步方法的区别" aria-hidden="true">#</a> 6.36 同步代码块与同步方法的区别？</h3><ol><li><p>同步代码块的锁的范围是比同步方法小的，一般来说锁的范围是于性能成反比的</p></li><li><p>同步代码块可以更加精确地控制锁的作用域（锁的作用域就是从锁被获取到其被释放的 时间），同步方法的锁的作用域就是整个方法</p></li><li><p>静态代码块可以选择对哪个对象加锁，但是静态方法只能给this对象加锁</p></li></ol><h3 id="_6-37-set如何保证元素不重复" tabindex="-1"><a class="header-anchor" href="#_6-37-set如何保证元素不重复" aria-hidden="true">#</a> 6.37 Set如何保证元素不重复？</h3><p>Set的实现可以分为两大类，分别是：HashSet和TreeSet</p><p>HashSet中，基本操作都是由HashMap底层实现的，因为HashSet底层是通过HashMap存储数据的。向HashSet中插入添加数据时，会计算出元素的hashcode，然后算出元素的存储位置，如果该位置为空，则直接添加，如果不为空，则通过equals方法比较元素是否相等，相等就不添加，不相等就找一个空位添加</p><p>TreeSet是通过key进行排序的，元素在插入TreeSet时compareTo方法要被调用，所以TreeSet的元素需要实Comparable接口，TreeSet是通过compareTo方法判断是否重复元素的</p><h3 id="_6-38-hashmap中的hash方法的原理" tabindex="-1"><a class="header-anchor" href="#_6-38-hashmap中的hash方法的原理" aria-hidden="true">#</a> 6.38 HashMap中的hash方法的原理</h3><h3 id="_6-39-常见的hash函数" tabindex="-1"><a class="header-anchor" href="#_6-39-常见的hash函数" aria-hidden="true">#</a> 6.39 常见的hash函数</h3><ul><li>直接定址法：直接以关键字k或者k加上某个常数（k + c）作为哈希地址</li><li>数字分析法：提取关键字中屈指比较均匀的数字作为哈希地址</li><li>除留余数法：用关键字k除以某个不大于哈希表长度m的数p，将所得的余数作为哈希表地址</li><li>分段叠加法：按照哈希表地址位数将关键字分成位数相等的几部分，其中最后一部分可以比较短。然后将这几部分相加，舍弃最高进位后的结果就是该关键字的哈希地址</li><li>平方取中法：如果关键字各个部分分布都不均匀的话，可以先求出它的平方值，然后按照需求去中间的几位作为哈希地址</li><li>伪随机数法：采用一个伪随机数当做哈希函数</li></ul><h3 id="_6-40-hashmap的数据结构" tabindex="-1"><a class="header-anchor" href="#_6-40-hashmap的数据结构" aria-hidden="true">#</a> 6.40 HashMap的数据结构</h3><blockquote><p>java中保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难，而链表的特点是：寻址困难，插入和删除容易。</p><p>常用的哈希函数的冲突解决办法中有一种犯法叫做链地址法，其实就是讲数组和链表组合在一起，发挥了两者的优势，我们可以将其理解为链表的数组。</p></blockquote><p>外表看似是一个数组，但是每个数组的成员是一个链表。这种数据结构所容纳的所有元素均好汉一个指针，用于元素见得连接诶。我们根据元素的自身特征把元素分配到不同的链表汇中去，反过来我们也是通过这些特征找到正确的链表，再从链表中找打正确的元素。其中根据元素特征计算元素数组下标的方法就是哈希算法，也就是hash()函数。</p><p>当我们要对一个链表数组中的某个 元素进行增删的时候，首先要知道他应该保存在这个链表数组中的哪个位置，即他在这个数 组中的下标。而 <code>hash()</code>方法的功能就是根据<code>Key</code>来定位其在<code>HashMap</code>中的位置。 <code>HashTable</code>、<code>ConcurrentHashMap</code> 同理。</p><h3 id="_6-41-collection如何迭代" tabindex="-1"><a class="header-anchor" href="#_6-41-collection如何迭代" aria-hidden="true">#</a> 6.41 Collection如何迭代？</h3><ol><li>通过普通for循环迭代</li><li>通过增强for循环迭代</li><li>使用Iterator迭代</li><li>使用Stream迭代</li></ol><h3 id="_6-42-enumeration和iterator的区别" tabindex="-1"><a class="header-anchor" href="#_6-42-enumeration和iterator的区别" aria-hidden="true">#</a> 6.42 Enumeration和Iterator的区别？</h3><ol><li>函数接口不同</li><li>Iterator支持fail-fast机制，而Enumeration不支持</li></ol><blockquote><p><strong>注意</strong>：Enumeration 迭代器只能遍历 Vector、Hashtable 这种古老的集合，因此通 常不要使用它，除非在某些极端情况下，不得不使用 Enumeration，否则都应该选择 Iterator 迭代器</p></blockquote><h3 id="_6-43-如何在遍历的同时删除arraylist的中的元素" tabindex="-1"><a class="header-anchor" href="#_6-43-如何在遍历的同时删除arraylist的中的元素" aria-hidden="true">#</a> 6.43 如何在遍历的同时删除ArrayList的中的元素？</h3><ol><li><p>直接使用普通for循环进行操作</p><ul><li>在foreach种不能进行，因为foreach中用到了Iterator比哪里，会导致fail-fast</li><li>但是可以使用普通for循环，因为普通for循环中没有用到Iterator遍历，不会导致fail-fast的检验</li><li>但是这种方案也存在一个问题，就是remove操作会改变List种元素的下标，可能存在漏删的情况</li></ul></li><li><p>直接使用Iterator进行操作</p><ul><li>直接使用Iterator提供的remove方法，还可以修改到expectedModCount的值，那么也就不会抛出异常了</li></ul></li><li><p>使用Java8种提供的filter过滤</p><ul><li>java8种可以把集合转换成流，对于流有一种filter操作，可以对原始Stream进行某项测试，通过测试的元素被留下来生成一个新的Stream</li></ul></li><li><p>使用增强for循环</p><ul><li>我们非常确定在一个集合中，某个即将删除的元素只包含一个的话， 比如对 Set 进行操作，那么其实也是可以使用增强 for 循环的，只要在删除之后，立刻结束循环体， 不要再继续进行遍历就可以了，也就是说不让代码执行到下一次的 next 方法</li></ul></li><li><p>直接使用fail-safe的集合类</p><ul><li>java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改</li></ul><blockquote><p>在 Java 中，除了一些普通地集合类以外，还有一些采用了 fail-safe 机制的集合类。 这样的集合容器在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝 的集合上进行遍历。 由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能 被迭代器检测到，所以不会触发 ConcurrentModificationException。</p><p>基于拷贝内容的优点是避免了 ConcurrentModificationException，但同样地，迭代 器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍 历期间原集合发生的修改迭代器是不知道的</p></blockquote><h3 id="copyonwritearraylist比较与arraylist所具有的特性" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist比较与arraylist所具有的特性" aria-hidden="true">#</a> CopyOnWriteArrayList比较与ArrayList所具有的特性</h3><p>支持高效率并发且是线程安全的 因为通常需要复制整个基础数组，所以可变操作（ add()、set() 和 remove() 等等）的开销很大 迭代器支持 hasNext(), next()等不可变 操作，但不支持可变 remove()等操作 使用迭代器进行遍历的速度很快，并且不会与其他 线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照</p></li></ol><hr><h4 id="stream" tabindex="-1"><a class="header-anchor" href="#stream" aria-hidden="true">#</a> Stream</h4><p>Stream使用一种类似用SQL语句从数据库查询数据的直观方式来提供一种对Java集合运算和表达的高阶抽象</p><p>Stream的特性和优点：</p><ul><li>无存储。Stream 不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一 个数组，Java 容器或 I/O channel 等</li><li>为函数式编程而生。对 Stream 的任何修改都不会修改背后的数据源，比如对 Stream 执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素 的新 Stream。</li><li>惰式执行。Stream 上的操作并不会立即执行，只有等到用户真正需要结果的时候才会 执行。</li><li>可消费性。Stream 只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那 样，想要再次遍历必须重新生成。</li></ul>',109);function n(o,d){return e(),i("div",null,[s,h(" more "),p])}const u=a(t,[["render",n],["__file","java-collection-01.html.vue"]]);export{u as default};
