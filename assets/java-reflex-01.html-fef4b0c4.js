import{_ as a,W as e,X as i,Y as l,Z as r,a0 as o}from"./framework-91490e6a.js";const h={},d=r("p",null,"Java基础常见面试题-反射",-1),n=o('<h1 id="java反射常见面试题总结" tabindex="-1"><a class="header-anchor" href="#java反射常见面试题总结" aria-hidden="true">#</a> Java反射常见面试题总结</h1><h3 id="反射的作用" tabindex="-1"><a class="header-anchor" href="#反射的作用" aria-hidden="true">#</a> 反射的作用</h3><ol><li>在运行时判断任意一个对象那个所属的类</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时任意调用一个对象的方法</li><li>在运行时构造任意一个类的对象</li></ol><h3 id="class类" tabindex="-1"><a class="header-anchor" href="#class类" aria-hidden="true">#</a> Class类</h3><p>Java 的 Class 类是 java 反射机制的基础,通过 Class 类我们可以获得关于一个类的相关信息</p><h3 id="反射机制的作用" tabindex="-1"><a class="header-anchor" href="#反射机制的作用" aria-hidden="true">#</a> 反射机制的作用</h3><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时获取类的对象</li><li>你在运行时访问 java 对象的属性，方法，构造方法等</li></ol><blockquote><p>静态编译：在编译时确定类型，绑定对象，即通过</p><p>动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了 Java 的灵活性，体现了多态的应用，有以降低类之间的藕合性</p></blockquote><h3 id="反射机制的优缺点" tabindex="-1"><a class="header-anchor" href="#反射机制的优缺点" aria-hidden="true">#</a> 反射机制的优缺点</h3><p>优点：</p><ul><li>可以实现动态创建对象和编译，体现出很大的灵活性（特别是在 J2EE 的开发中它的灵活性就表现得十分明显）</li><li>通过反射机制我们可以获得类的各种内容， 进行反编译。对于 JAVA 这种先编译再运行的语言来说，反射机制可以使代码更加灵活， 更加容易实现面向对象</li></ul><p>缺点：</p><ul><li>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉 JVM，我们希望做什么并且让它满足我们的要求。这类操作总是慢于直接执行相同的操作</li></ul><h3 id="反射与工厂模式实现ioc" tabindex="-1"><a class="header-anchor" href="#反射与工厂模式实现ioc" aria-hidden="true">#</a> 反射与工厂模式实现IOC</h3><blockquote><p>我们可以把 IOC 容器的工作模式看做是工厂模式的升华，可以把 IOC 容器看作是一个 工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言提供的反射机 制，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC 是把以前在工厂方法 里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分 隔开来，目的就是提高灵活性和可维护性</p></blockquote><h3 id="使用ioc框架应该注意什么" tabindex="-1"><a class="header-anchor" href="#使用ioc框架应该注意什么" aria-hidden="true">#</a> 使用IOC框架应该注意什么</h3><p>使用 IOC 框架产品能够给我们的开发过程带来很大的好处，但是也要充分认识引入 I OC 框架的缺点，做到心中有数，杜绝滥用框架。</p><ol><li>软件系统中由于引入了第三方 IOC 容器，生成对象的步骤变得有些复杂，本来是两者 之间的事情，又凭空多出一道手续，所以，我们在刚开始使用 IOC 框架的时候，会感 觉系统变得不太直观。所以，引入了一个全新的框架，就会增加团队成员学习和认识的 培训成本，并且在以后的运行维护中，还得让新加入者具备同样的知识体系</li><li>由于 IOC 容器生成对象是通过反射方式，在运行效率上有一定的损耗。如果你要追求 运行效率的话，就必须对此进行权衡</li><li>具体到 IOC 框架产品（比如 Spring）来讲，需要进行大量的配制工作，比较繁琐，对于一些小的项目而言，客观上也可能加大一些工作成本</li><li>IOC 框架产品本身的成熟度需要进行评估，如果引入一个不成熟的 IOC 框架产品，那 么会影响到整个项目，所以这也是一个隐性的风险</li></ol><blockquote><p>一些工作量不大的项目或者产品，不太适合使用 IOC 框架产品。另外，如果团队成员的知识能力欠缺，对于 IOC 框架产品缺乏深入的理解，也 不要贸然引入。最后，特别强调运行效率的项目或者产品，也不太适合引入 IOC 框架产品， 像 WEB2.0 网站就是这种情况。</p></blockquote><h3 id="动态代理与反射的关系" tabindex="-1"><a class="header-anchor" href="#动态代理与反射的关系" aria-hidden="true">#</a> 动态代理与反射的关系</h3><p>反射是动态代理的一种实现方式</p><h3 id="动态代理的几种实现方式" tabindex="-1"><a class="header-anchor" href="#动态代理的几种实现方式" aria-hidden="true">#</a> 动态代理的几种实现方式</h3><p>Java 中，实现动态代理有两种方式：</p><ol><li>JDK 动态代理：java.lang.reflect 包中的 Proxy 类和 InvocationHandler 接口提 供了生成动态代理类的能力</li><li>Cglib 动态代理：Cglib (Code Generation Library )是一个第三方代码生成类 库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展</li></ol><p>JDK 动态代理和 Cglib 动态代理的区别 JDK 的动态代理有一个限制，就是使用动态 代理的对象必须实现一个或多个接口。如果想代理没有实现接口的类，就可以使用 CGLIB 实现</p><p><strong>Cglib 与动态代理最大的区别就是</strong></p><p>使用动态代理的对象必须实现一个或多个接口 使用 cglib 代理的对象则无需实现接口，达到代理类无侵入</p><h3 id="aop" tabindex="-1"><a class="header-anchor" href="#aop" aria-hidden="true">#</a> AOP</h3><p>Spring AOP 中的动态代理主要有两种方式，JDK 动态代理和 CGLIB 动态代理 JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口。JDK动态代理的核心是InvocationHandler接口和Proxy类 如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类 CGLIB（Code Generation Library），是一个代码生成的类库，可以在运行时动态 的生成某个类的子类，注意，CGLIB 是通过继承的方式做的动态代理，因此如果某个类被 标记为 final，那么它是无法使用 CGLIB 做动态代理</p>',29);function t(c,s){return e(),i("div",null,[d,l(" more "),n])}const C=a(h,[["render",t],["__file","java-reflex-01.html.vue"]]);export{C as default};
