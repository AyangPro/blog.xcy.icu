import{_ as a,W as e,X as i,Y as n,Z as r,a0 as t}from"./framework-91490e6a.js";const h={},l=r("p",null,"Java基础常见面试题-枚举",-1),d=t('<h1 id="java枚举常见面试题" tabindex="-1"><a class="header-anchor" href="#java枚举常见面试题" aria-hidden="true">#</a> Java枚举常见面试题</h1><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h3><p>枚举类型（enum type）是指由一组固定的常量组成合法的类型。Java 中由关键字 enum 来定义一个枚举类型。下面就是 java 枚举类型的定义</p><h3 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h3><ol><li>使用关键字 enum</li><li>类型名称</li><li>一串允许的值</li><li>枚举可以单独定义在一个文件中，也可以嵌在其它 Java 类中，枚举类型和泛型中除了这样的基本要求外，用户还有一些其他选择</li><li>枚举可以实现一个或多个接口（Interface）</li><li>可以定义新的变量</li><li>可以定义新的方法</li><li>可以定义根据具体枚举值而相异的类</li></ol><blockquote><p><strong>总结</strong>：每当需要一组固定的常量的时候，如一周的天数、一年 四季等。或者是在我们编译前就知道其包含的所有值的集合。Java 1.5 的枚举能满足绝大 部分程序员的要求的，它的简明，易用的特点是很突出的</p></blockquote><h3 id="枚举的实现" tabindex="-1"><a class="header-anchor" href="#枚举的实现" aria-hidden="true">#</a> 枚举的实现</h3><p>通过反编译，我们可以看到，public final class T extends Enum，说明，该 类是继承了 Enum 类的，同时 final 关键字告诉我们，这个类也是不能被继承的</p><p>当我们使用 enum 来定义一个枚举类型的时候，编译器会自动帮我们创建一个 final 类型的类继承 Enum类，所以枚举类型不能被继承</p><h3 id="枚举与单例" tabindex="-1"><a class="header-anchor" href="#枚举与单例" aria-hidden="true">#</a> 枚举与单例</h3><p>当一个 Java 类第一次被真正使用 到的时候静态资源被初始化、Java 类的加载和初始化过程都是线程安全的（因为虚拟机在 加载枚举的类的时候，会使用 ClassLoader 的 loadClass 方法，而这个方法使用同步代 码块保证了线程安全）。所以，创建一个 enum 类型是线程安全的</p><p>也就是说，我们定义的一个枚举，在第一次被真正用到的时候，会被虚拟机加载并初始 化，而这个初始化过程是线程安全的。而我们知道，解决单例的并发问题，主要解决的就是 初始化过程中的线程安全问题</p><p>所以，由于枚举的以上特性，枚举实现的单例是天生线程安全的</p><h3 id="java-枚举如何比较" tabindex="-1"><a class="header-anchor" href="#java-枚举如何比较" aria-hidden="true">#</a> Java 枚举如何比较</h3><p>java 枚举值比较用 == 和 equals 方法没啥区别，两个随便用都是一样的效果</p><p>因为枚举 Enum 类的 equals 方法默认实现就是通过 == 来比较的</p><p>类似的 Enum 的 compareTo 方法比较的是 Enum 的 ordinal 顺序大小</p><p>类似的还有 Enum 的 name 方法和 toString 方法一样都返回的是 Enum 的 name 值</p><h3 id="switch-对枚举的支持" tabindex="-1"><a class="header-anchor" href="#switch-对枚举的支持" aria-hidden="true">#</a> switch 对枚举的支持</h3><p>Java 1.7 之前 switch 参数可用类型为 short、byte、int、char，枚举类型之所以 能使用其实是编译器层面实现的。</p><p>编译器会将枚举 switch 转换，但是实质还是 int 参数类型</p>',21);function s(c,o){return e(),i("div",null,[l,n(" more "),d])}const u=a(h,[["render",s],["__file","java-enum-01.html.vue"]]);export{u as default};
